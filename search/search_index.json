{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"api/","title":"API Reference","text":"<p>This section contains the detailed API documentation for Eunomia.</p> <p>Eunomia is developed and distributed through multiple libraries:</p> <ul> <li>The main library contains the Eunomia server and all its logic</li> <li>The core library contains shared functionality across all Eunomia libraries</li> <li>The SDKs libraries are meant to ease the interaction with the server from different programming languages</li> <li>The extensions libraries expand Eunomia's capabilities by integrating with popular frameworks and protocols in the AI ecosystem</li> </ul>"},{"location":"api/#libraries","title":"Libraries","text":"Name Package name Description Jump to Eunomia <code>eunomia-ai</code> Contains all logic for the Eunomia server and its exposed API  Page Eunomia Core <code>eunomia-core</code> Contains the shared functionalities such as data models and utilities  Page Eunomia SDKs <code>eunomia-sdk</code> The Eunomia SDKs for different languages  Page Eunomia Extenions <code>eunomia-[EXT_NAME]</code> The Eunomia extensions for different frameworks  Page"},{"location":"api/core/","title":"Eunomia Core","text":"<p>This section contains the documentation for the core package, containing shared functionality across all Eunomia packages and SDKs.</p> <p>It includes common data models, utility functions, and types that ensure consistency across all Eunomia components.</p>"},{"location":"api/core/#installation","title":"Installation","text":"<pre><code>pip install eunomia-core\n</code></pre>"},{"location":"api/core/#usage","title":"Usage","text":"<pre><code>from eunomia_core import *\n</code></pre>"},{"location":"api/core/#components","title":"Components","text":"<p>Eunomia Core is composed of the following components:</p> Component Description Jump to Schemas Common data schemas used for validation and serialization.  Page"},{"location":"api/core/schemas/","title":"Schemas","text":"<p>This page documents the schema classes used in Eunomia Core for data validation and serialization.</p>"},{"location":"api/core/schemas/#attribute-schemas","title":"Attribute Schemas","text":""},{"location":"api/core/schemas/#eunomia_core.schemas.Attribute","title":"<code>eunomia_core.schemas.Attribute</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pkgs/core/src/eunomia_core/schemas/entity.py</code> <pre><code>class Attribute(BaseModel):\n    key: str = Field(..., description=\"Attribute key\")\n    value: Any = Field(..., description=\"Attribute value\")\n\n    @field_validator(\"value\", mode=\"before\")\n    @classmethod\n    def parse_json(cls, v: Any) -&gt; Any:\n        if isinstance(v, str):\n            try:\n                return json.loads(v)\n            except json.JSONDecodeError:\n                return v\n        return v\n</code></pre>"},{"location":"api/core/schemas/#eunomia_core.schemas.AttributeInDb","title":"<code>eunomia_core.schemas.AttributeInDb</code>","text":"<p>               Bases: <code>Attribute</code></p> Source code in <code>pkgs/core/src/eunomia_core/schemas/entity.py</code> <pre><code>class AttributeInDb(Attribute):\n    updated_at: datetime = Field(\n        description=\"Time when this attribute was last updated\"\n    )\n    registered_at: datetime = Field(\n        description=\"Time when this attribute was first registered\"\n    )\n\n    model_config = ConfigDict(from_attributes=True)\n</code></pre>"},{"location":"api/core/schemas/#entity-schemas","title":"Entity Schemas","text":""},{"location":"api/core/schemas/#eunomia_core.schemas.EntityCreate","title":"<code>eunomia_core.schemas.EntityCreate</code>","text":"<p>               Bases: <code>EntityBase</code></p> Source code in <code>pkgs/core/src/eunomia_core/schemas/entity.py</code> <pre><code>class EntityCreate(EntityBase):\n    uri: Optional[str] = Field(\n        default_factory=lambda: generate_uri(),\n        description=\"Unique identifier for the entity, generated if not provided\",\n    )\n\n    @field_validator(\"attributes\", mode=\"before\")\n    @classmethod\n    def at_least_one_attribute(cls, v: list[Attribute]) -&gt; list[Attribute]:\n        if not v:\n            raise ValueError(\"At least one attribute must be provided\")\n        return v\n\n    @field_validator(\"uri\", mode=\"after\")\n    @classmethod\n    def enforce_uri(cls, v: str | None) -&gt; str:\n        if v is None:\n            return generate_uri()\n        return v\n</code></pre>"},{"location":"api/core/schemas/#eunomia_core.schemas.EntityUpdate","title":"<code>eunomia_core.schemas.EntityUpdate</code>","text":"<p>               Bases: <code>EntityBase</code></p> Source code in <code>pkgs/core/src/eunomia_core/schemas/entity.py</code> <pre><code>class EntityUpdate(EntityBase):\n    type: Optional[EntityType] = None  # type is not required for the attributes update\n\n    @field_validator(\"attributes\", mode=\"before\")\n    @classmethod\n    def at_least_one_attribute(cls, v: list[Attribute]) -&gt; list[Attribute]:\n        if not v:\n            raise ValueError(\"At least one attribute must be provided\")\n        return v\n</code></pre>"},{"location":"api/core/schemas/#eunomia_core.schemas.EntityCheck","title":"<code>eunomia_core.schemas.EntityCheck</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pkgs/core/src/eunomia_core/schemas/check.py</code> <pre><code>class EntityCheck(BaseModel):\n    uri: Optional[str] = Field(\n        default=None, description=\"Unique identifier for the entity\"\n    )\n    attributes: Optional[dict[str, Any]] = Field(\n        default_factory=dict, description=\"Entity attributes\"\n    )\n    type: EntityType = Field(..., description=\"Type of entity\")\n\n    @field_validator(\"attributes\", mode=\"before\")\n    @classmethod\n    def from_list(cls, v: list[Attribute] | dict) -&gt; dict[str, Any]:\n        if isinstance(v, list) and all(isinstance(attr, Attribute) for attr in v):\n            return {attr.key: attr.value for attr in v}\n        elif isinstance(v, list):\n            return {attr[\"key\"]: attr[\"value\"] for attr in v}\n        return v\n\n    @model_validator(mode=\"after\")\n    def either_uri_or_attributes(self) -&gt; \"EntityCheck\":\n        if not self.uri and not self.attributes:\n            raise ValueError(\"Either 'uri' or non-empty 'attributes' must be provided\")\n        return self\n</code></pre>"},{"location":"api/core/schemas/#eunomia_core.schemas.EntityInDb","title":"<code>eunomia_core.schemas.EntityInDb</code>","text":"<p>               Bases: <code>EntityBase</code></p> Source code in <code>pkgs/core/src/eunomia_core/schemas/entity.py</code> <pre><code>class EntityInDb(EntityBase):\n    attributes: list[AttributeInDb] = Field(..., description=\"Entity attributes\")\n    registered_at: datetime = Field(description=\"Time when this entity was registered\")\n\n    model_config = ConfigDict(from_attributes=True)\n\n    @property\n    def attributes_dict(self) -&gt; dict[str, Any]:\n        return {attr.key: attr.value for attr in self.attributes}\n</code></pre>"},{"location":"api/core/schemas/#check-schemas","title":"Check Schemas","text":""},{"location":"api/core/schemas/#eunomia_core.schemas.ResourceCheck","title":"<code>eunomia_core.schemas.ResourceCheck</code>","text":"<p>               Bases: <code>EntityCheck</code></p> Source code in <code>pkgs/core/src/eunomia_core/schemas/check.py</code> <pre><code>class ResourceCheck(EntityCheck):\n    type: Literal[EntityType.resource] = EntityType.resource\n</code></pre>"},{"location":"api/core/schemas/#eunomia_core.schemas.PrincipalCheck","title":"<code>eunomia_core.schemas.PrincipalCheck</code>","text":"<p>               Bases: <code>EntityCheck</code></p> Source code in <code>pkgs/core/src/eunomia_core/schemas/check.py</code> <pre><code>class PrincipalCheck(EntityCheck):\n    type: Literal[EntityType.principal] = EntityType.principal\n</code></pre>"},{"location":"api/core/schemas/#eunomia_core.schemas.CheckRequest","title":"<code>eunomia_core.schemas.CheckRequest</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pkgs/core/src/eunomia_core/schemas/check.py</code> <pre><code>class CheckRequest(BaseModel):\n    principal: PrincipalCheck = Field(\n        ..., description=\"The principal performing the action\"\n    )\n    resource: ResourceCheck = Field(..., description=\"The resource being acted on\")\n    action: str = Field(\n        default=\"access\", description=\"The action being performed on the resource\"\n    )\n</code></pre>"},{"location":"api/core/schemas/#eunomia_core.schemas.CheckResponse","title":"<code>eunomia_core.schemas.CheckResponse</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pkgs/core/src/eunomia_core/schemas/check.py</code> <pre><code>class CheckResponse(BaseModel):\n    allowed: bool = Field(..., description=\"Whether the action is allowed\")\n    reason: Optional[str] = Field(None, description=\"The reason for the decision\")\n</code></pre>"},{"location":"api/core/schemas/#eunomia_core.schemas.Policy","title":"<code>eunomia_core.schemas.Policy</code>","text":"<p>               Bases: <code>BaseModel</code></p> Source code in <code>pkgs/core/src/eunomia_core/schemas/policy.py</code> <pre><code>class Policy(BaseModel):\n    version: str = Field(\"1.0\", description=\"Version of the policy\")\n    name: str = Field(..., description=\"Name of the policy\")\n    description: Optional[str] = Field(\n        None, description=\"Human-readable description of the policy\"\n    )\n    rules: list[Rule] = Field(..., description=\"list of rules to evaluate\")\n    default_effect: PolicyEffect = Field(\n        PolicyEffect.DENY, description=\"Default effect if no rules match\"\n    )\n\n    @field_validator(\"name\", mode=\"before\")\n    @classmethod\n    def slugify_name(cls, v: str) -&gt; str:\n        result = slugify(v)\n        if not result:\n            raise ValueError(f\"Cannot create valid slug from: {v}\")\n        return result\n\n    model_config = ConfigDict(from_attributes=True, extra=\"forbid\")\n</code></pre>"},{"location":"api/extensions/","title":"Eunomia Extensions","text":"<p>Eunomia provides extensions with popular development frameworks and protocols in the AI ecosystem.</p> <p>Each extension is built and distributed as a separate package that can be installed with <code>pip</code>.</p>"},{"location":"api/extensions/#available-extensions","title":"Available extensions","text":"Extension name Package name Jump to MCP Middleware <code>eunomia-mcp</code>  Section LangChain <code>eunomia-langchain</code>  Page"},{"location":"api/extensions/langchain/","title":"LangChain","text":"<p>LangChain is a popular framework for building applications with LLMs.</p> <p>Eunomia provides two LangChain extensions that allow to:</p> <ul> <li>register documents loaded by any LangChain's loader to the Eunomia server</li> <li>enforce authorization policies on documents retrieved by any LangChain retriever</li> </ul> <p>These extensions help the configuration and enforcement of authorization policies on LLM applications that leverage LangChain.</p>"},{"location":"api/extensions/langchain/#installation","title":"Installation","text":"<p>Install the <code>eunomia-langchain</code> package via pip:</p> <pre><code>pip install eunomia-langchain\n</code></pre>"},{"location":"api/extensions/langchain/#api-reference","title":"API Reference","text":""},{"location":"api/extensions/langchain/#eunomia_langchain.document_loader.EunomiaLoader","title":"<code>eunomia_langchain.document_loader.EunomiaLoader</code>","text":"<p>A wrapper around LangChain loaders that sends documents to the Eunomia server.</p> <p>This class wraps any LangChain document loader and intercepts the document loading process to send their metadata as attributes to the Eunomia server. The Eunomia server assigns an identifier to each document, which can be used for checking access permissions by retrieving the associated document attributes at runtime.</p> <p>Parameters:</p> Name Type Description Default <code>loader</code> <code>BaseLoader</code> <p>The LangChain loader to wrap.</p> required <code>endpoint</code> <code>str</code> <p>The base URL endpoint of the Eunomia server.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The API key to use for the Eunomia server, only required when the server is hosted on cloud.</p> <code>None</code> Notes <p>The user can add additional metadata to the documents to be sent to the Eunomia server with respect to the ones obtained from the loader.</p> Source code in <code>pkgs/extensions/langchain/src/eunomia_langchain/document_loader.py</code> <pre><code>class EunomiaLoader:\n    \"\"\"\n    A wrapper around LangChain loaders that sends documents to the Eunomia server.\n\n    This class wraps any LangChain document loader and intercepts the document loading\n    process to send their metadata as attributes to the Eunomia server. The Eunomia server\n    assigns an identifier to each document, which can be used for checking access permissions\n    by retrieving the associated document attributes at runtime.\n\n    Parameters\n    ----------\n    loader : BaseLoader\n        The LangChain loader to wrap.\n    endpoint : str, optional\n        The base URL endpoint of the Eunomia server.\n    api_key : str, optional\n        The API key to use for the Eunomia server, only required when the server is hosted on cloud.\n\n    Notes\n    -----\n    The user can add additional metadata to the documents to be sent to the\n    Eunomia server with respect to the ones obtained from the loader.\n    \"\"\"\n\n    def __init__(\n        self,\n        loader: BaseLoader,\n        endpoint: str | None = None,\n        api_key: str | None = None,\n    ):\n        self._loader = loader\n        self._client = EunomiaClient(endpoint=endpoint, api_key=api_key)\n\n    def _process_document_sync(\n        self, doc: Document, additional_metadata: dict | None = None\n    ) -&gt; Document:\n        if additional_metadata is None:\n            additional_metadata = {}\n\n        if not hasattr(doc, \"metadata\") or doc.metadata is None:\n            doc.metadata = {}\n        doc.metadata.update(additional_metadata)\n\n        response_data = self._client.register_entity(\n            type=enums.EntityType.resource, attributes=doc.metadata\n        )\n        doc.metadata[\"eunomia_uri\"] = response_data.uri\n        return doc\n\n    async def _process_document_async(\n        self, doc: Document, additional_metadata: dict | None = None\n    ) -&gt; Document:\n        if additional_metadata is None:\n            additional_metadata = {}\n\n        if not hasattr(doc, \"metadata\") or doc.metadata is None:\n            doc.metadata = {}\n        doc.metadata.update(additional_metadata)\n\n        loop = asyncio.get_running_loop()\n        response_data = await loop.run_in_executor(\n            None,\n            lambda: self._client.register_entity(\n                type=enums.EntityType.resource, attributes=doc.metadata\n            ),\n        )\n        doc.metadata[\"eunomia_uri\"] = response_data.uri\n        return doc\n\n    async def alazy_load(\n        self, additional_metadata: dict | None = None\n    ) -&gt; AsyncIterator[Document]:\n        \"\"\"Load documents lazily and asynchronously, registering them with the Eunomia server.\n\n        Parameters\n        ----------\n        additional_metadata : dict, optional\n            Additional metadata to be sent to the Eunomia server.\n\n        Yields\n        ------\n        Document\n            Documents with Eunomia identifiers added to their metadata as 'eunomia_uri',\n            yielded one by one.\n\n        Examples\n        --------\n        &gt;&gt;&gt; import asyncio\n        &gt;&gt;&gt; from langchain_community.document_loaders.csv_loader import CSVLoader\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; async def process_docs():\n        ...     loader = CSVLoader(\"data.csv\")\n        ...     wrapped_loader = EunomiaLoader(loader)\n        ...     async for doc in wrapped_loader.alazy_load(additional_metadata={\"group\": \"financials\"}):\n        ...         await process_document(doc)\n        &gt;&gt;&gt;\n        &gt;&gt;&gt; asyncio.run(process_docs())\n        \"\"\"\n        if additional_metadata is None:\n            additional_metadata = {}\n\n        async for doc in self._loader.alazy_load():\n            processed_doc = await self._process_document_async(doc, additional_metadata)\n            yield processed_doc\n\n    async def aload(self, additional_metadata: dict | None = None) -&gt; List[Document]:\n        \"\"\"Load documents asynchronously and register them with the Eunomia server.\n\n        Parameters\n        ----------\n        additional_metadata : dict, optional\n            Additional metadata to be sent to the Eunomia server.\n\n        Returns\n        -------\n        List[Document]\n            The list of loaded documents with Eunomia identifiers added to their metadata\n            as 'eunomia_uri'.\n\n        Examples\n        --------\n        &gt;&gt;&gt; import asyncio\n        &gt;&gt;&gt; from langchain_community.document_loaders.csv_loader import CSVLoader\n        &gt;&gt;&gt; loader = CSVLoader(\"data.csv\")\n        &gt;&gt;&gt; wrapped_loader = EunomiaLoader(loader)\n        &gt;&gt;&gt; docs = asyncio.run(wrapped_loader.aload(additional_metadata={\"group\": \"financials\"}))\n        \"\"\"\n        if additional_metadata is None:\n            additional_metadata = {}\n\n        documents = await self._loader.aload()\n        processed_docs = [\n            await self._process_document_async(doc, additional_metadata)\n            for doc in documents\n        ]\n        return processed_docs\n\n    def lazy_load(self, additional_metadata: dict | None = None) -&gt; Iterator[Document]:\n        \"\"\"Load documents lazily and synchronously, registering them with the Eunomia server.\n\n        Parameters\n        ----------\n        additional_metadata : dict, optional\n            Additional metadata to be sent to the Eunomia server.\n\n        Yields\n        ------\n        Document\n            Documents with Eunomia identifiers added to their metadata as 'eunomia_uri',\n            yielded one by one.\n\n        Examples\n        --------\n        &gt;&gt;&gt; from langchain_community.document_loaders.csv_loader import CSVLoader\n        &gt;&gt;&gt; loader = CSVLoader(\"data.csv\")\n        &gt;&gt;&gt; wrapped_loader = EunomiaLoader(loader)\n        &gt;&gt;&gt; for doc in wrapped_loader.lazy_load(additional_metadata={\"group\": \"financials\"}):\n        ...     process_document(doc)\n        \"\"\"\n        if additional_metadata is None:\n            additional_metadata = {}\n\n        for doc in self._loader.lazy_load():\n            processed_doc = self._process_document_sync(doc, additional_metadata)\n            yield processed_doc\n\n    def load(self, additional_metadata: dict | None = None) -&gt; List[Document]:\n        \"\"\"Load documents synchronously and register them with the Eunomia server.\n\n        Parameters\n        ----------\n        additional_metadata : dict, optional\n            Additional metadata to be sent to the Eunomia server.\n\n        Returns\n        -------\n        List[Document]\n            The list of loaded documents with Eunomia identifiers added to their metadata\n            as 'eunomia_uri'.\n\n        Examples\n        --------\n        &gt;&gt;&gt; from langchain_community.document_loaders.csv_loader import CSVLoader\n        &gt;&gt;&gt; loader = CSVLoader(\"data.csv\")\n        &gt;&gt;&gt; wrapped_loader = EunomiaLoader(loader)\n        &gt;&gt;&gt; docs = wrapped_loader.load(additional_metadata={\"group\": \"financials\"})\n        \"\"\"\n        if additional_metadata is None:\n            additional_metadata = {}\n\n        documents = self._loader.load()\n        processed_docs = [\n            self._process_document_sync(doc, additional_metadata) for doc in documents\n        ]\n        return processed_docs\n\n    def __getattr__(self, name):\n        # Delegate any attribute or method lookup to the underlying loader\n        # if not explicitly defined in this wrapper.\n        return getattr(self._loader, name)\n</code></pre>"},{"location":"api/extensions/langchain/#eunomia_langchain.document_loader.EunomiaLoader.alazy_load","title":"<code>alazy_load(additional_metadata=None)</code>  <code>async</code>","text":"<p>Load documents lazily and asynchronously, registering them with the Eunomia server.</p> <p>Parameters:</p> Name Type Description Default <code>additional_metadata</code> <code>dict</code> <p>Additional metadata to be sent to the Eunomia server.</p> <code>None</code> <p>Yields:</p> Type Description <code>Document</code> <p>Documents with Eunomia identifiers added to their metadata as 'eunomia_uri', yielded one by one.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; from langchain_community.document_loaders.csv_loader import CSVLoader\n&gt;&gt;&gt;\n&gt;&gt;&gt; async def process_docs():\n...     loader = CSVLoader(\"data.csv\")\n...     wrapped_loader = EunomiaLoader(loader)\n...     async for doc in wrapped_loader.alazy_load(additional_metadata={\"group\": \"financials\"}):\n...         await process_document(doc)\n&gt;&gt;&gt;\n&gt;&gt;&gt; asyncio.run(process_docs())\n</code></pre> Source code in <code>pkgs/extensions/langchain/src/eunomia_langchain/document_loader.py</code> <pre><code>async def alazy_load(\n    self, additional_metadata: dict | None = None\n) -&gt; AsyncIterator[Document]:\n    \"\"\"Load documents lazily and asynchronously, registering them with the Eunomia server.\n\n    Parameters\n    ----------\n    additional_metadata : dict, optional\n        Additional metadata to be sent to the Eunomia server.\n\n    Yields\n    ------\n    Document\n        Documents with Eunomia identifiers added to their metadata as 'eunomia_uri',\n        yielded one by one.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import asyncio\n    &gt;&gt;&gt; from langchain_community.document_loaders.csv_loader import CSVLoader\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; async def process_docs():\n    ...     loader = CSVLoader(\"data.csv\")\n    ...     wrapped_loader = EunomiaLoader(loader)\n    ...     async for doc in wrapped_loader.alazy_load(additional_metadata={\"group\": \"financials\"}):\n    ...         await process_document(doc)\n    &gt;&gt;&gt;\n    &gt;&gt;&gt; asyncio.run(process_docs())\n    \"\"\"\n    if additional_metadata is None:\n        additional_metadata = {}\n\n    async for doc in self._loader.alazy_load():\n        processed_doc = await self._process_document_async(doc, additional_metadata)\n        yield processed_doc\n</code></pre>"},{"location":"api/extensions/langchain/#eunomia_langchain.document_loader.EunomiaLoader.aload","title":"<code>aload(additional_metadata=None)</code>  <code>async</code>","text":"<p>Load documents asynchronously and register them with the Eunomia server.</p> <p>Parameters:</p> Name Type Description Default <code>additional_metadata</code> <code>dict</code> <p>Additional metadata to be sent to the Eunomia server.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Document]</code> <p>The list of loaded documents with Eunomia identifiers added to their metadata as 'eunomia_uri'.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; import asyncio\n&gt;&gt;&gt; from langchain_community.document_loaders.csv_loader import CSVLoader\n&gt;&gt;&gt; loader = CSVLoader(\"data.csv\")\n&gt;&gt;&gt; wrapped_loader = EunomiaLoader(loader)\n&gt;&gt;&gt; docs = asyncio.run(wrapped_loader.aload(additional_metadata={\"group\": \"financials\"}))\n</code></pre> Source code in <code>pkgs/extensions/langchain/src/eunomia_langchain/document_loader.py</code> <pre><code>async def aload(self, additional_metadata: dict | None = None) -&gt; List[Document]:\n    \"\"\"Load documents asynchronously and register them with the Eunomia server.\n\n    Parameters\n    ----------\n    additional_metadata : dict, optional\n        Additional metadata to be sent to the Eunomia server.\n\n    Returns\n    -------\n    List[Document]\n        The list of loaded documents with Eunomia identifiers added to their metadata\n        as 'eunomia_uri'.\n\n    Examples\n    --------\n    &gt;&gt;&gt; import asyncio\n    &gt;&gt;&gt; from langchain_community.document_loaders.csv_loader import CSVLoader\n    &gt;&gt;&gt; loader = CSVLoader(\"data.csv\")\n    &gt;&gt;&gt; wrapped_loader = EunomiaLoader(loader)\n    &gt;&gt;&gt; docs = asyncio.run(wrapped_loader.aload(additional_metadata={\"group\": \"financials\"}))\n    \"\"\"\n    if additional_metadata is None:\n        additional_metadata = {}\n\n    documents = await self._loader.aload()\n    processed_docs = [\n        await self._process_document_async(doc, additional_metadata)\n        for doc in documents\n    ]\n    return processed_docs\n</code></pre>"},{"location":"api/extensions/langchain/#eunomia_langchain.document_loader.EunomiaLoader.lazy_load","title":"<code>lazy_load(additional_metadata=None)</code>","text":"<p>Load documents lazily and synchronously, registering them with the Eunomia server.</p> <p>Parameters:</p> Name Type Description Default <code>additional_metadata</code> <code>dict</code> <p>Additional metadata to be sent to the Eunomia server.</p> <code>None</code> <p>Yields:</p> Type Description <code>Document</code> <p>Documents with Eunomia identifiers added to their metadata as 'eunomia_uri', yielded one by one.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from langchain_community.document_loaders.csv_loader import CSVLoader\n&gt;&gt;&gt; loader = CSVLoader(\"data.csv\")\n&gt;&gt;&gt; wrapped_loader = EunomiaLoader(loader)\n&gt;&gt;&gt; for doc in wrapped_loader.lazy_load(additional_metadata={\"group\": \"financials\"}):\n...     process_document(doc)\n</code></pre> Source code in <code>pkgs/extensions/langchain/src/eunomia_langchain/document_loader.py</code> <pre><code>def lazy_load(self, additional_metadata: dict | None = None) -&gt; Iterator[Document]:\n    \"\"\"Load documents lazily and synchronously, registering them with the Eunomia server.\n\n    Parameters\n    ----------\n    additional_metadata : dict, optional\n        Additional metadata to be sent to the Eunomia server.\n\n    Yields\n    ------\n    Document\n        Documents with Eunomia identifiers added to their metadata as 'eunomia_uri',\n        yielded one by one.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from langchain_community.document_loaders.csv_loader import CSVLoader\n    &gt;&gt;&gt; loader = CSVLoader(\"data.csv\")\n    &gt;&gt;&gt; wrapped_loader = EunomiaLoader(loader)\n    &gt;&gt;&gt; for doc in wrapped_loader.lazy_load(additional_metadata={\"group\": \"financials\"}):\n    ...     process_document(doc)\n    \"\"\"\n    if additional_metadata is None:\n        additional_metadata = {}\n\n    for doc in self._loader.lazy_load():\n        processed_doc = self._process_document_sync(doc, additional_metadata)\n        yield processed_doc\n</code></pre>"},{"location":"api/extensions/langchain/#eunomia_langchain.document_loader.EunomiaLoader.load","title":"<code>load(additional_metadata=None)</code>","text":"<p>Load documents synchronously and register them with the Eunomia server.</p> <p>Parameters:</p> Name Type Description Default <code>additional_metadata</code> <code>dict</code> <p>Additional metadata to be sent to the Eunomia server.</p> <code>None</code> <p>Returns:</p> Type Description <code>List[Document]</code> <p>The list of loaded documents with Eunomia identifiers added to their metadata as 'eunomia_uri'.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from langchain_community.document_loaders.csv_loader import CSVLoader\n&gt;&gt;&gt; loader = CSVLoader(\"data.csv\")\n&gt;&gt;&gt; wrapped_loader = EunomiaLoader(loader)\n&gt;&gt;&gt; docs = wrapped_loader.load(additional_metadata={\"group\": \"financials\"})\n</code></pre> Source code in <code>pkgs/extensions/langchain/src/eunomia_langchain/document_loader.py</code> <pre><code>def load(self, additional_metadata: dict | None = None) -&gt; List[Document]:\n    \"\"\"Load documents synchronously and register them with the Eunomia server.\n\n    Parameters\n    ----------\n    additional_metadata : dict, optional\n        Additional metadata to be sent to the Eunomia server.\n\n    Returns\n    -------\n    List[Document]\n        The list of loaded documents with Eunomia identifiers added to their metadata\n        as 'eunomia_uri'.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from langchain_community.document_loaders.csv_loader import CSVLoader\n    &gt;&gt;&gt; loader = CSVLoader(\"data.csv\")\n    &gt;&gt;&gt; wrapped_loader = EunomiaLoader(loader)\n    &gt;&gt;&gt; docs = wrapped_loader.load(additional_metadata={\"group\": \"financials\"})\n    \"\"\"\n    if additional_metadata is None:\n        additional_metadata = {}\n\n    documents = self._loader.load()\n    processed_docs = [\n        self._process_document_sync(doc, additional_metadata) for doc in documents\n    ]\n    return processed_docs\n</code></pre>"},{"location":"api/extensions/langchain/#eunomia_langchain.retriever.EunomiaRetriever","title":"<code>eunomia_langchain.retriever.EunomiaRetriever</code>","text":"<p>               Bases: <code>BaseRetriever</code></p> <p>A wrapper around LangChain retrievers that filters allowed documents using the Eunomia server.</p> <p>This class wraps any LangChain retriever and intercepts the document retrieval process to filter allowed documents using the Eunomia server.</p> <p>Parameters:</p> Name Type Description Default <code>retriever</code> <code>BaseRetriever</code> <p>The LangChain retriever to wrap.</p> required <code>principal</code> <code>PrincipalCheck</code> <p>The principal to use for the Eunomia server. Defined either with its identifier (uri), attributes or both.</p> required <code>endpoint</code> <code>str</code> <p>The base URL endpoint of the Eunomia server.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The API key to use for the Eunomia server, only required when the server is hosted on cloud.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; from eunomia_core import schemas\n&gt;&gt;&gt; from eunomia_langchain.retriever import EunomiaRetriever\n&gt;&gt;&gt; from langchain_community.retrievers import BM25Retriever\n&gt;&gt;&gt; from langchain_core.documents import Document\n&gt;&gt;&gt; retriever = BM25Retriever.from_documents(\n...     [\n...         Document(page_content=\"foo\", metadata={\"confidentiality\": \"public\"}),\n...         Document(page_content=\"bar\", metadata={\"confidentiality\": \"public\"}),\n...         Document(page_content=\"foo bar\", metadata={\"confidentiality\": \"private\"}),\n...     ]\n... )\n&gt;&gt;&gt; wrapped_retriever = EunomiaRetriever(\n...     retriever=retriever,\n...     principal=schemas.PrincipalCheck(uri=\"test-uri\"),\n... )\n&gt;&gt;&gt; docs = wrapped_retriever.invoke(\"foo\")\n</code></pre> Source code in <code>pkgs/extensions/langchain/src/eunomia_langchain/retriever.py</code> <pre><code>class EunomiaRetriever(BaseRetriever):\n    \"\"\"\n    A wrapper around LangChain retrievers that filters allowed documents using the Eunomia server.\n\n    This class wraps any LangChain retriever and intercepts the document retrieval\n    process to filter allowed documents using the Eunomia server.\n\n    Parameters\n    ----------\n    retriever : BaseRetriever\n        The LangChain retriever to wrap.\n    principal : schemas.PrincipalCheck\n        The principal to use for the Eunomia server. Defined either with its identifier (uri), attributes or both.\n    endpoint : str, optional\n        The base URL endpoint of the Eunomia server.\n    api_key : str, optional\n        The API key to use for the Eunomia server, only required when the server is hosted on cloud.\n\n    Examples\n    --------\n    &gt;&gt;&gt; from eunomia_core import schemas\n    &gt;&gt;&gt; from eunomia_langchain.retriever import EunomiaRetriever\n    &gt;&gt;&gt; from langchain_community.retrievers import BM25Retriever\n    &gt;&gt;&gt; from langchain_core.documents import Document\n    &gt;&gt;&gt; retriever = BM25Retriever.from_documents(\n    ...     [\n    ...         Document(page_content=\"foo\", metadata={\"confidentiality\": \"public\"}),\n    ...         Document(page_content=\"bar\", metadata={\"confidentiality\": \"public\"}),\n    ...         Document(page_content=\"foo bar\", metadata={\"confidentiality\": \"private\"}),\n    ...     ]\n    ... )\n    &gt;&gt;&gt; wrapped_retriever = EunomiaRetriever(\n    ...     retriever=retriever,\n    ...     principal=schemas.PrincipalCheck(uri=\"test-uri\"),\n    ... )\n    &gt;&gt;&gt; docs = wrapped_retriever.invoke(\"foo\")\n    \"\"\"\n\n    def __init__(\n        self,\n        retriever: BaseRetriever,\n        principal: schemas.PrincipalCheck,\n        endpoint: str | None = None,\n        api_key: str | None = None,\n    ):\n        super().__init__()\n        self._retriever = retriever\n        self._principal = principal\n        self._client = EunomiaClient(endpoint=endpoint, api_key=api_key)\n\n    def _check_docs_access(self, docs: list[Document]) -&gt; list[Document]:\n        return [\n            doc\n            for doc in docs\n            if self._client.check(\n                resource_uri=doc.metadata.pop(\"eunomia_uri\", None),\n                resource_attributes=doc.metadata,\n                principal_uri=self._principal.uri,\n                principal_attributes=self._principal.attributes,\n            ).allowed\n        ]\n\n    def _get_relevant_documents(self, query: str) -&gt; list[Document]:\n        docs = self._retriever.invoke(query)\n        return self._check_docs_access(docs)\n\n    async def _acheck_doc_access(\n        self, doc: Document\n    ) -&gt; tuple[Document, schemas.CheckResponse]:\n        return (\n            doc,\n            await asyncio.to_thread(\n                self._client.check,\n                resource_uri=doc.metadata.pop(\"eunomia_uri\", None),\n                resource_attributes=doc.metadata,\n                principal_uri=self._principal.uri,\n                principal_attributes=self._principal.attributes,\n            ),\n        )\n\n    async def _acheck_docs_access(self, docs: list[Document]) -&gt; list[Document]:\n        results = await asyncio.gather(*[self._acheck_doc_access(doc) for doc in docs])\n        return [doc for doc, response in results if response.allowed]\n\n    async def _aget_relevant_documents(self, query: str) -&gt; list[Document]:\n        docs = await self._retriever.ainvoke(query)\n        return await self._acheck_docs_access(docs)\n</code></pre>"},{"location":"api/extensions/mcp/","title":"MCP","text":"<p>The Eunomia MCP Middleware extension has its own dedicated section: visit the MCP Middleware Section</p>"},{"location":"api/main/","title":"Eunomia Server","text":"<p>This section contains the documentation for the main package containing the Eunomia server.</p> <p>The Eunomia server is a standalone service to handle the authorization logic of your AI Agent. The server can be self-hosted, exposing a REST API to your application.</p>"},{"location":"api/main/#installation","title":"Installation","text":"<pre><code>pip install eunomia-ai\n</code></pre>"},{"location":"api/main/#usage","title":"Usage","text":"<p>Run the server with:</p> <pre><code>eunomia server\n</code></pre>"},{"location":"api/main/#components","title":"Components","text":"<p>Explore detailed reference of single components of Eunomia:</p> Component Description Jump to Server API Exposes endpoints for applications to interact with the server.  Page"},{"location":"api/main/api/","title":"Server API","text":"<p>The API exposes endpoints to interact with the Eunomia server.</p> <p>The API is built with FastAPI.</p>"},{"location":"api/main/api/#api-structure","title":"API Structure","text":"<p>Eunomia provides two distinct API categories:</p>"},{"location":"api/main/api/#standard-api-public","title":"Standard API (Public)","text":"<p>The standard API is designed for authorization checks and is meant to be used by your applications and AI agents. These endpoints are publicly accessible and do not require authentication:</p> <ul> <li><code>POST /check</code>: Check if a principal has permissions to perform an action on a resource</li> <li><code>POST /check/bulk</code>: Perform a set of permission checks in a single request</li> </ul>"},{"location":"api/main/api/#admin-api-protected","title":"Admin API (Protected)","text":"<p>The admin API is designed for server configuration and management tasks. These endpoints are prefixed with <code>/admin</code> and can optionally be protected with a pre-shared key (PSK) for security:</p> <ul> <li><code>GET /admin/policies</code>: Get all policies</li> <li><code>POST /admin/policies</code>: Create a new policy</li> <li><code>POST /admin/policies/simple</code>: Create a simple policy with a single rule</li> <li><code>GET /admin/policies/{name}</code>: Get a policy by name</li> <li><code>DELETE /admin/policies/{name}</code>: Delete a policy by name</li> </ul> <p>If the <code>registry</code> fetcher is enabled (which is by default), the following endpoints are also available:</p> <ul> <li><code>GET /admin/fetchers/registry/entities</code>: Get entities with pagination</li> <li><code>GET /admin/fetchers/registry/entities/$count</code>: Get the total number of entities</li> <li><code>POST /admin/fetchers/registry/entities</code>: Register a new entity in the system</li> <li><code>GET /admin/fetchers/registry/entities/{uri}</code>: Get an entity by URI</li> <li><code>PUT /admin/fetchers/registry/entities/{uri}</code>: Update an existing entity</li> <li><code>DELETE /admin/fetchers/registry/entities/{uri}</code>: Delete an entity from the system</li> </ul>"},{"location":"api/main/api/#admin-api-authentication","title":"Admin API Authentication","text":""},{"location":"api/main/api/#server-side","title":"Server-side","text":"<p>To enable Admin API authentication, configure the following environment variable for the Eunomia server:</p> <pre><code>ADMIN_AUTHN_REQUIRED=true\nADMIN_API_KEY=your-secure-admin-key-here\n</code></pre>"},{"location":"api/main/api/#client-side","title":"Client-side","text":"<p>When using the Admin API endpoints, include the pre-shared key in the request headers:</p> <pre><code>WAY-API-KEY: your-secure-admin-key-here\n</code></pre> <p>If you are using one of the Eunomia SDKs, the API key can be provided in the client constructor or as an environment variable and it will be automatically added to the request headers.</p>"},{"location":"api/sdks/","title":"Eunomia SDKs","text":"<p>Eunomia provides SDKs to ease the interaction with the server from different languages.</p> <p>Each SDK is built and distributed as a separate package that can be installed with <code>pip</code> or <code>npm</code>.</p>"},{"location":"api/sdks/#available-sdks","title":"Available SDKs","text":"SDK name Package name Published to Jump to Python <code>eunomia-sdk</code> PyPI  Page TypeScript <code>eunomia-sdk</code> NPM  Page"},{"location":"api/sdks/python/","title":"Python SDK","text":"<p>Eunomia offers a Python client that enables users to interact with the Eunomia server.</p> <p>The client allows you to register resources and principals with their metadata to the Eunomia server, as well as verify permissions of principals performing actions on resources. These features simplify the integration of the Eunomia server into your Python applications.</p>"},{"location":"api/sdks/python/#installation","title":"Installation","text":"<p>Install the <code>eunomia-sdk</code> package via pip:</p> <pre><code>pip install eunomia-sdk\n</code></pre>"},{"location":"api/sdks/python/#usage","title":"Usage","text":""},{"location":"api/sdks/python/#standard-api","title":"Standard API","text":"<p>Use the standard API for authorization checks in your application:</p> <pre><code>from eunomia_sdk import EunomiaClient\n\nclient = EunomiaClient(endpoint=\"http://localhost:8421\")\n\n# Check if a principal has permissions to perform an action on a resource\nresponse = client.check(\n    principal_uri=\"user:123\",\n    resource_uri=\"document:456\",\n    action=\"read\",\n)\n\nprint(f\"Is allowed: {response.allowed}\")\n</code></pre>"},{"location":"api/sdks/python/#admin-api-usage","title":"Admin API Usage","text":"<p>Use the admin API for server configuration and entity management:</p> <pre><code>from eunomia_sdk import EunomiaClient\n\n# For admin API usage authentication via API key might be required\nclient = EunomiaClient(\n    endpoint=\"http://localhost:8421\",\n    api_key=\"your-admin-api-key\"  # or set WAY_API_KEY environment variable\n)\n\n# Register a resource with metadata\nresource = client.register_entity(\n    type=\"resource\",\n    uri=\"document:456\",\n    attributes={\n        \"name\": \"sensitive_document\",\n        \"type\": \"document\",\n        \"classification\": \"confidential\",\n    },\n)\n\n# Register a principal with metadata\nprincipal = client.register_entity(\n    type=\"principal\",\n    uri=\"user:123\",\n    attributes={\n        \"name\": \"user_123\",\n        \"role\": \"analyst\",\n        \"department\": \"research\",\n    },\n)\n</code></pre>"},{"location":"api/sdks/python/#api-reference","title":"API Reference","text":""},{"location":"api/sdks/python/#eunomia_sdk.client.EunomiaClient","title":"<code>eunomia_sdk.client.EunomiaClient</code>","text":"<p>A client for interacting with the Eunomia server.</p> <p>This client provides methods to register resources and principals, and to check permissions.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The base URL endpoint of the Eunomia server. Defaults to \"http://localhost:8421\" if not provided.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The API key for authenticating with the server. Defaults to the environment variable \"WAY_API_KEY\" if not provided.</p> <code>None</code> Source code in <code>pkgs/sdks/python/src/eunomia_sdk/client.py</code> <pre><code>class EunomiaClient:\n    \"\"\"\n    A client for interacting with the Eunomia server.\n\n    This client provides methods to register resources and principals,\n    and to check permissions.\n\n    Parameters\n    ----------\n    endpoint : str, optional\n        The base URL endpoint of the Eunomia server.\n        Defaults to \"http://localhost:8421\" if not provided.\n    api_key : str, optional\n        The API key for authenticating with the server.\n        Defaults to the environment variable \"WAY_API_KEY\" if not provided.\n    \"\"\"\n\n    def __init__(self, endpoint: str | None = None, api_key: str | None = None) -&gt; None:\n        self._endpoint = endpoint if endpoint is not None else \"http://localhost:8421\"\n        self._api_key = (\n            api_key if api_key is not None else os.getenv(\"WAY_API_KEY\", None)\n        )\n\n        headers = {}\n        if self._api_key is not None:\n            headers[\"WAY-API-KEY\"] = self._api_key\n\n        self.client = httpx.Client(base_url=self._endpoint, headers=headers, timeout=60)\n\n    def _handle_response(self, response: httpx.Response) -&gt; None:\n        try:\n            response.raise_for_status()\n            return\n        except httpx.HTTPStatusError as e:\n            raise httpx.HTTPStatusError(\n                f\"{e}\\nResponse: {e.response.text}\",\n                request=e.request,\n                response=e.response,\n            ) from None\n\n    def check(\n        self,\n        principal_uri: str | None = None,\n        resource_uri: str | None = None,\n        principal_attributes: dict | None = None,\n        resource_attributes: dict | None = None,\n        action: str = \"access\",\n    ) -&gt; schemas.CheckResponse:\n        \"\"\"\n        Check whether a principal has permissions to perform an action on a specific resource.\n\n        Parameters\n        ----------\n        principal_uri : str, optional\n            The identifier of the principal. Can be provided for registered principals to automatically retrieve attributes.\n        resource_uri : str, optional\n            The identifier of the resource. Can be provided for registered resources to automatically retrieve attributes.\n        principal_attributes : dict, optional\n            The attributes of the principal. Shall be provided if the principal is not registered.\n        resource_attributes : dict, optional\n            The attributes of the resource. Shall be provided if the resource is not registered.\n        action : str, optional\n            The action to check permissions for. Defaults to \"access\".\n\n        Returns\n        -------\n        schemas.CheckResponse\n            The response containing the allowed flag and the reason for the decision.\n\n        Raises\n        ------\n        httpx.HTTPStatusError\n            If the HTTP request returns an unsuccessful status code.\n        \"\"\"\n        if principal_attributes is None:\n            principal_attributes = {}\n        if resource_attributes is None:\n            resource_attributes = {}\n\n        request = schemas.CheckRequest(\n            principal=schemas.PrincipalCheck(\n                uri=principal_uri, attributes=principal_attributes\n            ),\n            resource=schemas.ResourceCheck(\n                uri=resource_uri, attributes=resource_attributes\n            ),\n            action=action,\n        )\n        response = self.client.post(\"/check\", json=request.model_dump())\n        self._handle_response(response)\n        return schemas.CheckResponse.model_validate(response.json())\n\n    def bulk_check(\n        self, check_requests: list[schemas.CheckRequest]\n    ) -&gt; list[schemas.CheckResponse]:\n        \"\"\"\n        Perform a set of permission checks in a single request.\n\n        Parameters\n        ----------\n        check_requests : list[schemas.CheckRequest]\n            The list of check requests to perform.\n\n        Returns\n        -------\n        list[schemas.CheckResponse]\n            The list of results of the check requests.\n        \"\"\"\n        response = self.client.post(\n            \"/check/bulk\",\n            json=[\n                schemas.CheckRequest.model_validate(request).model_dump()\n                for request in check_requests\n            ],\n        )\n        self._handle_response(response)\n        return [\n            schemas.CheckResponse.model_validate(result) for result in response.json()\n        ]\n\n    def register_entity(\n        self, type: enums.EntityType, attributes: dict, uri: str | None = None\n    ) -&gt; schemas.EntityInDb:\n        \"\"\"\n        Register a new entity with the Eunomia server.\n\n        This method registers a new entity with its attributes to the Eunomia server.\n        If no uri identifier is provided, the server will generate a random UUID.\n\n        Parameters\n        ----------\n        type : enums.EntityType\n            The type of entity to register. Either \"resource\" or \"principal\".\n        attributes : dict\n            The attributes to associate with the entity.\n        uri : str | None, optional\n            The uri for the entity. If not provided, the server will generate a random UUID.\n\n        Returns\n        -------\n        schemas.EntityInDb\n            The newly registered entity.\n\n        Raises\n        ------\n        httpx.HTTPStatusError\n            If the HTTP request returns an unsuccessful status code.\n        \"\"\"\n        entity = schemas.EntityCreate(type=type, attributes=attributes, uri=uri)\n        response = self.client.post(\n            \"/admin/fetchers/registry/entities\", json=entity.model_dump()\n        )\n        self._handle_response(response)\n        return schemas.EntityInDb.model_validate(response.json())\n\n    def update_entity(\n        self, uri: str, attributes: dict, override: bool = False\n    ) -&gt; schemas.EntityInDb:\n        \"\"\"\n        Update the attributes of an existing entity.\n\n        Parameters\n        ----------\n        uri : str\n            The uri of the entity to update.\n        attributes : dict\n            The attributes to update.\n        override : bool, default=False\n            If True, the existing attributes are deleted and the new attributes are added.\n            If False, the existing attributes are maintaned or updated in case of overlap,\n            and the additional new attributes are added.\n\n        Returns\n        -------\n        schemas.EntityInDb\n            The updated entity.\n\n        Raises\n        ------\n        httpx.HTTPStatusError\n            If the HTTP request returns an unsuccessful status code.\n        \"\"\"\n        entity = schemas.EntityUpdate(uri=uri, attributes=attributes)\n        response = self.client.put(\n            f\"/admin/fetchers/registry/entities/{uri}\",\n            json=entity.model_dump(),\n            params={\"override\": override},\n        )\n        self._handle_response(response)\n        return schemas.EntityInDb.model_validate(response.json())\n\n    def delete_entity(self, uri: str) -&gt; bool:\n        \"\"\"\n        Delete an entity from the Eunomia server.\n\n        Parameters\n        ----------\n        uri : str\n            The uri of the entity to delete.\n\n        Raises\n        ------\n        httpx.HTTPStatusError\n            If the HTTP request returns an unsuccessful status code.\n        \"\"\"\n        response = self.client.delete(f\"/admin/fetchers/registry/entities/{uri}\")\n        self._handle_response(response)\n        return response.json()\n\n    def create_policy(self, request: schemas.Policy) -&gt; schemas.Policy:\n        \"\"\"\n        Create a new policy and store it in the Eunomia server.\n\n        Parameters\n        ----------\n        request : schemas.Policy\n            The policy to create.\n\n        Raises\n        ------\n        httpx.HTTPStatusError\n            If the HTTP request returns an unsuccessful status code.\n        \"\"\"\n        response = self.client.post(\"/admin/policies\", json=request.model_dump())\n        self._handle_response(response)\n        return schemas.Policy.model_validate(response.json())\n\n    def create_simple_policy(\n        self, request: schemas.CheckRequest, name: str\n    ) -&gt; schemas.Policy:\n        \"\"\"\n        Create a new simple policy with a single rule and store it in the Eunomia server.\n\n        Parameters\n        ----------\n        request : schemas.CheckRequest\n            The request to create the policy from.\n        name : str\n            The name of the policy.\n\n        Raises\n        ------\n        httpx.HTTPStatusError\n            If the HTTP request returns an unsuccessful status code.\n        \"\"\"\n        response = self.client.post(\n            \"/admin/policies/simple\", json=request.model_dump(), params={\"name\": name}\n        )\n        self._handle_response(response)\n        return schemas.Policy.model_validate(response.json())\n\n    def get_policies(self) -&gt; list[schemas.Policy]:\n        \"\"\"\n        Get all policies from the Eunomia server.\n\n        Returns\n        -------\n        list[schemas.Policy]\n            The list of all policies.\n\n        Raises\n        ------\n        httpx.HTTPStatusError\n            If the HTTP request returns an unsuccessful status code.\n        \"\"\"\n        response = self.client.get(\"/admin/policies\")\n        self._handle_response(response)\n        return [schemas.Policy.model_validate(policy) for policy in response.json()]\n\n    def delete_policy(self, name: str) -&gt; bool:\n        \"\"\"\n        Delete a policy from the Eunomia server.\n\n        Parameters\n        ----------\n        name : str\n            The name of the policy to delete.\n\n        Returns\n        -------\n        bool\n            True if the policy was successfully deleted.\n\n        Raises\n        ------\n        httpx.HTTPStatusError\n            If the HTTP request returns an unsuccessful status code.\n        \"\"\"\n        response = self.client.delete(f\"/admin/policies/{name}\")\n        self._handle_response(response)\n        return response.json()\n\n    def issue_passport(\n        self, uri: str, attributes: dict | None = None, ttl: int | None = None\n    ) -&gt; schemas.PassportIssueResponse:\n        \"\"\"\n        Issue a passport JWT token for the given URI.\n\n        Parameters\n        ----------\n        uri : str\n            The entity URI to issue the passport for. Usually the agent identifier.\n        attributes : dict, optional\n            Additional attributes to include in the passport. Defaults to {}.\n        ttl : int, optional\n            Time to live in seconds. If not provided, the server default will be used.\n\n        Returns\n        -------\n        schemas.PassportIssueResponse\n            The response containing the passport token, passport ID, and expiration time.\n\n        Raises\n        ------\n        httpx.HTTPStatusError\n            If the HTTP request returns an unsuccessful status code.\n        \"\"\"\n        if attributes is None:\n            attributes = {}\n\n        request = schemas.PassportIssueRequest(uri=uri, attributes=attributes, ttl=ttl)\n        response = self.client.post(\n            \"/admin/fetchers/passport/issue\", json=request.model_dump()\n        )\n        self._handle_response(response)\n        return schemas.PassportIssueResponse.model_validate(response.json())\n</code></pre>"},{"location":"api/sdks/python/#eunomia_sdk.client.EunomiaClient.bulk_check","title":"<code>bulk_check(check_requests)</code>","text":"<p>Perform a set of permission checks in a single request.</p> <p>Parameters:</p> Name Type Description Default <code>check_requests</code> <code>list[CheckRequest]</code> <p>The list of check requests to perform.</p> required <p>Returns:</p> Type Description <code>list[CheckResponse]</code> <p>The list of results of the check requests.</p> Source code in <code>pkgs/sdks/python/src/eunomia_sdk/client.py</code> <pre><code>def bulk_check(\n    self, check_requests: list[schemas.CheckRequest]\n) -&gt; list[schemas.CheckResponse]:\n    \"\"\"\n    Perform a set of permission checks in a single request.\n\n    Parameters\n    ----------\n    check_requests : list[schemas.CheckRequest]\n        The list of check requests to perform.\n\n    Returns\n    -------\n    list[schemas.CheckResponse]\n        The list of results of the check requests.\n    \"\"\"\n    response = self.client.post(\n        \"/check/bulk\",\n        json=[\n            schemas.CheckRequest.model_validate(request).model_dump()\n            for request in check_requests\n        ],\n    )\n    self._handle_response(response)\n    return [\n        schemas.CheckResponse.model_validate(result) for result in response.json()\n    ]\n</code></pre>"},{"location":"api/sdks/python/#eunomia_sdk.client.EunomiaClient.check","title":"<code>check(principal_uri=None, resource_uri=None, principal_attributes=None, resource_attributes=None, action='access')</code>","text":"<p>Check whether a principal has permissions to perform an action on a specific resource.</p> <p>Parameters:</p> Name Type Description Default <code>principal_uri</code> <code>str</code> <p>The identifier of the principal. Can be provided for registered principals to automatically retrieve attributes.</p> <code>None</code> <code>resource_uri</code> <code>str</code> <p>The identifier of the resource. Can be provided for registered resources to automatically retrieve attributes.</p> <code>None</code> <code>principal_attributes</code> <code>dict</code> <p>The attributes of the principal. Shall be provided if the principal is not registered.</p> <code>None</code> <code>resource_attributes</code> <code>dict</code> <p>The attributes of the resource. Shall be provided if the resource is not registered.</p> <code>None</code> <code>action</code> <code>str</code> <p>The action to check permissions for. Defaults to \"access\".</p> <code>'access'</code> <p>Returns:</p> Type Description <code>CheckResponse</code> <p>The response containing the allowed flag and the reason for the decision.</p> <p>Raises:</p> Type Description <code>HTTPStatusError</code> <p>If the HTTP request returns an unsuccessful status code.</p> Source code in <code>pkgs/sdks/python/src/eunomia_sdk/client.py</code> <pre><code>def check(\n    self,\n    principal_uri: str | None = None,\n    resource_uri: str | None = None,\n    principal_attributes: dict | None = None,\n    resource_attributes: dict | None = None,\n    action: str = \"access\",\n) -&gt; schemas.CheckResponse:\n    \"\"\"\n    Check whether a principal has permissions to perform an action on a specific resource.\n\n    Parameters\n    ----------\n    principal_uri : str, optional\n        The identifier of the principal. Can be provided for registered principals to automatically retrieve attributes.\n    resource_uri : str, optional\n        The identifier of the resource. Can be provided for registered resources to automatically retrieve attributes.\n    principal_attributes : dict, optional\n        The attributes of the principal. Shall be provided if the principal is not registered.\n    resource_attributes : dict, optional\n        The attributes of the resource. Shall be provided if the resource is not registered.\n    action : str, optional\n        The action to check permissions for. Defaults to \"access\".\n\n    Returns\n    -------\n    schemas.CheckResponse\n        The response containing the allowed flag and the reason for the decision.\n\n    Raises\n    ------\n    httpx.HTTPStatusError\n        If the HTTP request returns an unsuccessful status code.\n    \"\"\"\n    if principal_attributes is None:\n        principal_attributes = {}\n    if resource_attributes is None:\n        resource_attributes = {}\n\n    request = schemas.CheckRequest(\n        principal=schemas.PrincipalCheck(\n            uri=principal_uri, attributes=principal_attributes\n        ),\n        resource=schemas.ResourceCheck(\n            uri=resource_uri, attributes=resource_attributes\n        ),\n        action=action,\n    )\n    response = self.client.post(\"/check\", json=request.model_dump())\n    self._handle_response(response)\n    return schemas.CheckResponse.model_validate(response.json())\n</code></pre>"},{"location":"api/sdks/python/#eunomia_sdk.client.EunomiaClient.create_policy","title":"<code>create_policy(request)</code>","text":"<p>Create a new policy and store it in the Eunomia server.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>Policy</code> <p>The policy to create.</p> required <p>Raises:</p> Type Description <code>HTTPStatusError</code> <p>If the HTTP request returns an unsuccessful status code.</p> Source code in <code>pkgs/sdks/python/src/eunomia_sdk/client.py</code> <pre><code>def create_policy(self, request: schemas.Policy) -&gt; schemas.Policy:\n    \"\"\"\n    Create a new policy and store it in the Eunomia server.\n\n    Parameters\n    ----------\n    request : schemas.Policy\n        The policy to create.\n\n    Raises\n    ------\n    httpx.HTTPStatusError\n        If the HTTP request returns an unsuccessful status code.\n    \"\"\"\n    response = self.client.post(\"/admin/policies\", json=request.model_dump())\n    self._handle_response(response)\n    return schemas.Policy.model_validate(response.json())\n</code></pre>"},{"location":"api/sdks/python/#eunomia_sdk.client.EunomiaClient.create_simple_policy","title":"<code>create_simple_policy(request, name)</code>","text":"<p>Create a new simple policy with a single rule and store it in the Eunomia server.</p> <p>Parameters:</p> Name Type Description Default <code>request</code> <code>CheckRequest</code> <p>The request to create the policy from.</p> required <code>name</code> <code>str</code> <p>The name of the policy.</p> required <p>Raises:</p> Type Description <code>HTTPStatusError</code> <p>If the HTTP request returns an unsuccessful status code.</p> Source code in <code>pkgs/sdks/python/src/eunomia_sdk/client.py</code> <pre><code>def create_simple_policy(\n    self, request: schemas.CheckRequest, name: str\n) -&gt; schemas.Policy:\n    \"\"\"\n    Create a new simple policy with a single rule and store it in the Eunomia server.\n\n    Parameters\n    ----------\n    request : schemas.CheckRequest\n        The request to create the policy from.\n    name : str\n        The name of the policy.\n\n    Raises\n    ------\n    httpx.HTTPStatusError\n        If the HTTP request returns an unsuccessful status code.\n    \"\"\"\n    response = self.client.post(\n        \"/admin/policies/simple\", json=request.model_dump(), params={\"name\": name}\n    )\n    self._handle_response(response)\n    return schemas.Policy.model_validate(response.json())\n</code></pre>"},{"location":"api/sdks/python/#eunomia_sdk.client.EunomiaClient.delete_entity","title":"<code>delete_entity(uri)</code>","text":"<p>Delete an entity from the Eunomia server.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The uri of the entity to delete.</p> required <p>Raises:</p> Type Description <code>HTTPStatusError</code> <p>If the HTTP request returns an unsuccessful status code.</p> Source code in <code>pkgs/sdks/python/src/eunomia_sdk/client.py</code> <pre><code>def delete_entity(self, uri: str) -&gt; bool:\n    \"\"\"\n    Delete an entity from the Eunomia server.\n\n    Parameters\n    ----------\n    uri : str\n        The uri of the entity to delete.\n\n    Raises\n    ------\n    httpx.HTTPStatusError\n        If the HTTP request returns an unsuccessful status code.\n    \"\"\"\n    response = self.client.delete(f\"/admin/fetchers/registry/entities/{uri}\")\n    self._handle_response(response)\n    return response.json()\n</code></pre>"},{"location":"api/sdks/python/#eunomia_sdk.client.EunomiaClient.delete_policy","title":"<code>delete_policy(name)</code>","text":"<p>Delete a policy from the Eunomia server.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the policy to delete.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if the policy was successfully deleted.</p> <p>Raises:</p> Type Description <code>HTTPStatusError</code> <p>If the HTTP request returns an unsuccessful status code.</p> Source code in <code>pkgs/sdks/python/src/eunomia_sdk/client.py</code> <pre><code>def delete_policy(self, name: str) -&gt; bool:\n    \"\"\"\n    Delete a policy from the Eunomia server.\n\n    Parameters\n    ----------\n    name : str\n        The name of the policy to delete.\n\n    Returns\n    -------\n    bool\n        True if the policy was successfully deleted.\n\n    Raises\n    ------\n    httpx.HTTPStatusError\n        If the HTTP request returns an unsuccessful status code.\n    \"\"\"\n    response = self.client.delete(f\"/admin/policies/{name}\")\n    self._handle_response(response)\n    return response.json()\n</code></pre>"},{"location":"api/sdks/python/#eunomia_sdk.client.EunomiaClient.get_policies","title":"<code>get_policies()</code>","text":"<p>Get all policies from the Eunomia server.</p> <p>Returns:</p> Type Description <code>list[Policy]</code> <p>The list of all policies.</p> <p>Raises:</p> Type Description <code>HTTPStatusError</code> <p>If the HTTP request returns an unsuccessful status code.</p> Source code in <code>pkgs/sdks/python/src/eunomia_sdk/client.py</code> <pre><code>def get_policies(self) -&gt; list[schemas.Policy]:\n    \"\"\"\n    Get all policies from the Eunomia server.\n\n    Returns\n    -------\n    list[schemas.Policy]\n        The list of all policies.\n\n    Raises\n    ------\n    httpx.HTTPStatusError\n        If the HTTP request returns an unsuccessful status code.\n    \"\"\"\n    response = self.client.get(\"/admin/policies\")\n    self._handle_response(response)\n    return [schemas.Policy.model_validate(policy) for policy in response.json()]\n</code></pre>"},{"location":"api/sdks/python/#eunomia_sdk.client.EunomiaClient.issue_passport","title":"<code>issue_passport(uri, attributes=None, ttl=None)</code>","text":"<p>Issue a passport JWT token for the given URI.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The entity URI to issue the passport for. Usually the agent identifier.</p> required <code>attributes</code> <code>dict</code> <p>Additional attributes to include in the passport. Defaults to {}.</p> <code>None</code> <code>ttl</code> <code>int</code> <p>Time to live in seconds. If not provided, the server default will be used.</p> <code>None</code> <p>Returns:</p> Type Description <code>PassportIssueResponse</code> <p>The response containing the passport token, passport ID, and expiration time.</p> <p>Raises:</p> Type Description <code>HTTPStatusError</code> <p>If the HTTP request returns an unsuccessful status code.</p> Source code in <code>pkgs/sdks/python/src/eunomia_sdk/client.py</code> <pre><code>def issue_passport(\n    self, uri: str, attributes: dict | None = None, ttl: int | None = None\n) -&gt; schemas.PassportIssueResponse:\n    \"\"\"\n    Issue a passport JWT token for the given URI.\n\n    Parameters\n    ----------\n    uri : str\n        The entity URI to issue the passport for. Usually the agent identifier.\n    attributes : dict, optional\n        Additional attributes to include in the passport. Defaults to {}.\n    ttl : int, optional\n        Time to live in seconds. If not provided, the server default will be used.\n\n    Returns\n    -------\n    schemas.PassportIssueResponse\n        The response containing the passport token, passport ID, and expiration time.\n\n    Raises\n    ------\n    httpx.HTTPStatusError\n        If the HTTP request returns an unsuccessful status code.\n    \"\"\"\n    if attributes is None:\n        attributes = {}\n\n    request = schemas.PassportIssueRequest(uri=uri, attributes=attributes, ttl=ttl)\n    response = self.client.post(\n        \"/admin/fetchers/passport/issue\", json=request.model_dump()\n    )\n    self._handle_response(response)\n    return schemas.PassportIssueResponse.model_validate(response.json())\n</code></pre>"},{"location":"api/sdks/python/#eunomia_sdk.client.EunomiaClient.register_entity","title":"<code>register_entity(type, attributes, uri=None)</code>","text":"<p>Register a new entity with the Eunomia server.</p> <p>This method registers a new entity with its attributes to the Eunomia server. If no uri identifier is provided, the server will generate a random UUID.</p> <p>Parameters:</p> Name Type Description Default <code>type</code> <code>EntityType</code> <p>The type of entity to register. Either \"resource\" or \"principal\".</p> required <code>attributes</code> <code>dict</code> <p>The attributes to associate with the entity.</p> required <code>uri</code> <code>str | None</code> <p>The uri for the entity. If not provided, the server will generate a random UUID.</p> <code>None</code> <p>Returns:</p> Type Description <code>EntityInDb</code> <p>The newly registered entity.</p> <p>Raises:</p> Type Description <code>HTTPStatusError</code> <p>If the HTTP request returns an unsuccessful status code.</p> Source code in <code>pkgs/sdks/python/src/eunomia_sdk/client.py</code> <pre><code>def register_entity(\n    self, type: enums.EntityType, attributes: dict, uri: str | None = None\n) -&gt; schemas.EntityInDb:\n    \"\"\"\n    Register a new entity with the Eunomia server.\n\n    This method registers a new entity with its attributes to the Eunomia server.\n    If no uri identifier is provided, the server will generate a random UUID.\n\n    Parameters\n    ----------\n    type : enums.EntityType\n        The type of entity to register. Either \"resource\" or \"principal\".\n    attributes : dict\n        The attributes to associate with the entity.\n    uri : str | None, optional\n        The uri for the entity. If not provided, the server will generate a random UUID.\n\n    Returns\n    -------\n    schemas.EntityInDb\n        The newly registered entity.\n\n    Raises\n    ------\n    httpx.HTTPStatusError\n        If the HTTP request returns an unsuccessful status code.\n    \"\"\"\n    entity = schemas.EntityCreate(type=type, attributes=attributes, uri=uri)\n    response = self.client.post(\n        \"/admin/fetchers/registry/entities\", json=entity.model_dump()\n    )\n    self._handle_response(response)\n    return schemas.EntityInDb.model_validate(response.json())\n</code></pre>"},{"location":"api/sdks/python/#eunomia_sdk.client.EunomiaClient.update_entity","title":"<code>update_entity(uri, attributes, override=False)</code>","text":"<p>Update the attributes of an existing entity.</p> <p>Parameters:</p> Name Type Description Default <code>uri</code> <code>str</code> <p>The uri of the entity to update.</p> required <code>attributes</code> <code>dict</code> <p>The attributes to update.</p> required <code>override</code> <code>bool</code> <p>If True, the existing attributes are deleted and the new attributes are added. If False, the existing attributes are maintaned or updated in case of overlap, and the additional new attributes are added.</p> <code>False</code> <p>Returns:</p> Type Description <code>EntityInDb</code> <p>The updated entity.</p> <p>Raises:</p> Type Description <code>HTTPStatusError</code> <p>If the HTTP request returns an unsuccessful status code.</p> Source code in <code>pkgs/sdks/python/src/eunomia_sdk/client.py</code> <pre><code>def update_entity(\n    self, uri: str, attributes: dict, override: bool = False\n) -&gt; schemas.EntityInDb:\n    \"\"\"\n    Update the attributes of an existing entity.\n\n    Parameters\n    ----------\n    uri : str\n        The uri of the entity to update.\n    attributes : dict\n        The attributes to update.\n    override : bool, default=False\n        If True, the existing attributes are deleted and the new attributes are added.\n        If False, the existing attributes are maintaned or updated in case of overlap,\n        and the additional new attributes are added.\n\n    Returns\n    -------\n    schemas.EntityInDb\n        The updated entity.\n\n    Raises\n    ------\n    httpx.HTTPStatusError\n        If the HTTP request returns an unsuccessful status code.\n    \"\"\"\n    entity = schemas.EntityUpdate(uri=uri, attributes=attributes)\n    response = self.client.put(\n        f\"/admin/fetchers/registry/entities/{uri}\",\n        json=entity.model_dump(),\n        params={\"override\": override},\n    )\n    self._handle_response(response)\n    return schemas.EntityInDb.model_validate(response.json())\n</code></pre>"},{"location":"api/sdks/typescript/","title":"TypeScript SDK","text":"<p>Eunomia offers a TypeScript client that enables users to interact with the Eunomia server.</p> <p>The client allows you to register resources and principals with their metadata to the Eunomia server, verify access control between principals and resources, update entities, and manage policies. These features simplify the integration of the Eunomia server into your TypeScript or JavaScript applications.</p>"},{"location":"api/sdks/typescript/#installation","title":"Installation","text":"<p>Install the <code>eunomia-sdk</code> package via npm:</p> <pre><code>npm install eunomia-sdk\n</code></pre>"},{"location":"api/sdks/typescript/#usage","title":"Usage","text":""},{"location":"api/sdks/typescript/#standard-api","title":"Standard API","text":"<p>Use the standard API for authorization checks in your application:</p> <pre><code>import { EunomiaClient } from \"eunomia-sdk\";\n\nconst client = new EunomiaClient({\n  endpoint: \"http://localhost:8421\",\n});\n\n// Check if a principal has permissions to perform an action on a resource\nconst response = await client.check({\n  principalUri: \"user:123\",\n  resourceUri: \"document:456\",\n  action: \"read\",\n});\n\nconsole.log(`Is allowed: ${response.allowed}`);\n</code></pre> <pre><code>import { EunomiaClient, EntityType } from \"eunomia-sdk\";\n\n// For admin API usage authentication via API key might be required\nconst client = new EunomiaClient({\n  endpoint: \"http://localhost:8421\",\n  apiKey: \"my-api-key\",\n});\n\n// Register a resource with metadata\nconst resource = await client.registerEntity({\n  type: EntityType.Resource,\n  uri: \"document:456\",\n  attributes: {\n    name: \"sensitive_document\",\n    type: \"document\",\n    classification: \"confidential\",\n  },\n});\n\n// Register a principal with metadata\nconst principal = await client.registerEntity({\n  type: EntityType.Principal,\n  uri: \"user:123\",\n  attributes: {\n    name: \"user_123\",\n    role: \"analyst\",\n    department: \"research\",\n  },\n});\n</code></pre>"},{"location":"api/sdks/typescript/#api-reference","title":"API Reference","text":""},{"location":"api/sdks/typescript/#eunomiaclient","title":"EunomiaClient","text":"<p>A client for interacting with the Eunomia server.</p> <p>Creates a new <code>EunomiaClient</code> instance with the following options:</p> <ul> <li><code>endpoint</code>: The base URL endpoint of the Eunomia server, defaults to \"http://localhost:8421\"</li> <li><code>apiKey</code>: The API key for authentication, defaults to the env variable <code>WAY_API_KEY</code></li> </ul>"},{"location":"api/sdks/typescript/#check","title":"check","text":"<p>Checks whether a principal has permissions to perform an action on a resource.</p> <pre><code>async check(options: {\n  principalUri?: string;\n  resourceUri?: string;\n  principalAttributes?: Record&lt;string, string&gt;;\n  resourceAttributes?: Record&lt;string, string&gt;;\n}): Promise&lt;boolean&gt;\n</code></pre>"},{"location":"api/sdks/typescript/#registerentity","title":"registerEntity","text":"<p>Registers a new entity with the Eunomia server.</p> <pre><code>async registerEntity(options: {\n  type: EntityType;\n  attributes: Record&lt;string, string&gt;;\n  uri?: string;\n}): Promise&lt;EntityInDb&gt;\n</code></pre>"},{"location":"api/sdks/typescript/#updateentity","title":"updateEntity","text":"<p>Updates the attributes of an existing entity. If override is true, all existing attributes are replaced; otherwise, they are merged.</p> <pre><code>async updateEntity(options: {\n  uri: string;\n  attributes: Record&lt;string, string&gt;;\n  override?: boolean;\n}): Promise&lt;EntityInDb&gt;\n</code></pre>"},{"location":"api/sdks/typescript/#deleteentity","title":"deleteEntity","text":"<p>Deletes an entity from the Eunomia server.</p> <pre><code>async deleteEntity(options: { uri: string }): Promise&lt;void&gt;\n</code></pre>"},{"location":"api/sdks/typescript/#createpolicy","title":"createPolicy","text":"<p>Creates a new policy and saves it to the local file system.</p> <pre><code>async createPolicy(options: {\n  policy: Policy;\n  filename?: string;\n}): Promise&lt;void&gt;\n</code></pre>"},{"location":"community/","title":"Join the Community","text":"<p>We are committed to building a community around Eunomia, for people that are interested in authorization for LLM-based applications.</p> <p>There you can ask questions, share feedback and ideas, and get help from other users.</p> <p>Join the Discord </p>"},{"location":"community/contribute/","title":"How to Contribute","text":""},{"location":"community/contribute/#code-contribution","title":"Code Contribution","text":""},{"location":"community/contribute/#your-development-branch","title":"Your development branch","text":"<p>First, fork the <code>eunomia</code> repository and then clone your forked repository locally:</p> HTTPSSSH <pre><code>git clone https://github.com/&lt;YOUR_GITHUB_USERNAME&gt;/eunomia.git\n</code></pre> <pre><code>git clone git@github.com:&lt;YOUR_GITHUB_USERNAME&gt;/eunomia.git\n</code></pre> <p>Once in the cloned repository directory, make a branch with your username and description of the pull request:</p> <pre><code>git checkout -B &lt;YOUR_GITHUB_USERNAME&gt;/&lt;PR_DESCRIPTION&gt;\n</code></pre>"},{"location":"community/contribute/#python-environment","title":"Python environment","text":"<p>Install the required dependecies with uv:</p> <pre><code>uv sync\n</code></pre> <p>If you are developing one of the additional packages (SDKs or extensions), you can install the dependencies for all packages:</p> <pre><code>uv sync --all-packages\n</code></pre>"},{"location":"community/contribute/#testing-and-formatting","title":"Testing and formatting","text":"<p>Before pushing your changes, ensure the tests pass and the code style aligns:</p> <pre><code>uv run pytest\nuv run ruff check\nuv run ruff format --check\n</code></pre> <p>Note: a GitHub workflow will check the tests and formatting and reject the PR if it doesn't pass, so please make sure it passes locally.</p>"},{"location":"community/contribute/#improving-the-documentation","title":"Improving the Documentation","text":"<p>Install the required dependecies with uv including the documentation dependencies:</p> <pre><code>uv sync --group docs --all-packages\n</code></pre> <p>To build the documentation and serve it locally, run the following command in the repository's root folder; the documentation will update every time you make a change:</p> <pre><code>uv run mkdocs serve\n</code></pre> <p>The documentation is built with Material for MkDocs, refer to their documentation for more information on how to use it.</p>"},{"location":"community/contribute/#open-a-pull-request","title":"Open a Pull Request","text":"<p>We actively welcome your pull requests; this is the workflow you should follow:</p> Step Description Jump to 1 Create your new branch from main in your forked repo  Branch Setup 2 Add tests, if needed, and ensure all tests pass  Testing 3 Update documentation for API changes  Documentation 4 Open a pull request  GitHub PRs"},{"location":"community/license/","title":"License","text":"<p>Eunomia is licensed under Apache 2.0.</p> <p>To comply with the licence you need to add the following notice at the top every file that uses part of Eunomia's code: <pre><code>Copyright 2024, eunomia authors\n\nLicensed under the Apache License, Version 2.0 (the \"License\");\nyou may not use this file except in compliance with the License.\nYou may obtain a copy of the License at\n\n    http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software\ndistributed under the License is distributed on an \"AS IS\" BASIS,\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\nSee the License for the specific language governing permissions and\nlimitations under the License.\n</code></pre></p> <p>You can read the full license here.</p>"},{"location":"mcp_middleware/","title":"Eunomia MCP Middleware","text":"<p>Add policy-based authorization to your Model Context Protocol (MCP) servers built with FastMCP with one line of code.</p> <p>Note</p> <p>Eunomia is the official authorization middleware of FastMCP!</p>"},{"location":"mcp_middleware/#what-is-eunomia-mcp-middleware","title":"What is Eunomia MCP Middleware?","text":"<p>With the Eunomia MCP Middleware, you can control which tools, resources and prompts MCP clients can view and execute on your server. Define dynamic JSON-based policies and obtain a comprehensive audit log of all access attempts and violations.</p>"},{"location":"mcp_middleware/#key-features","title":"Key Features","text":"<ul> <li>\ud83d\udd12 Policy-Based Authorization: Control which agents can access which MCP tools, resources, and prompts</li> <li>\ud83d\udcca Audit Logging: Track all authorization decisions and violations</li> <li>\ud83d\udd04 Centralized Policy Enforcement: Optionally use a remote Eunomia server for centralized policy enforcement</li> <li>\u26a1 FastMCP Integration: One-line middleware integration with FastMCP servers</li> <li>\ud83d\udd27 Flexible Configuration: JSON-based policies for complex dynamic rules with CLI tooling</li> </ul>"},{"location":"mcp_middleware/#how-it-works","title":"How It Works","text":"<p>The Eunomia middleware intercepts all MCP requests to your server and automatically maps MCP methods to authorization checks.</p>"},{"location":"mcp_middleware/#listing-operations","title":"Listing Operations","text":"<p>The middleware behaves as a filter for listing operations (<code>tools/list</code>, <code>resources/list</code>, <code>prompts/list</code>), hiding to the client components that are not authorized by the defined policies.</p> <pre><code>sequenceDiagram\n    participant MCPClient as MCP Client\n    participant EunomiaMiddleware as Eunomia Middleware\n    participant MCPServer as FastMCP Server\n    participant EunomiaServer as Eunomia Server\n\n    MCPClient-&gt;&gt;EunomiaMiddleware: MCP Listing Request (e.g., tools/list)\n    EunomiaMiddleware-&gt;&gt;MCPServer: MCP Listing Request\n    MCPServer--&gt;&gt;EunomiaMiddleware: MCP Listing Response\n    EunomiaMiddleware-&gt;&gt;EunomiaServer: Authorization Checks\n    EunomiaServer-&gt;&gt;EunomiaMiddleware: Authorization Decisions\n    EunomiaMiddleware--&gt;&gt;MCPClient: Filtered MCP Listing Response</code></pre>"},{"location":"mcp_middleware/#execution-operations","title":"Execution Operations","text":"<p>The middleware behaves as a firewall for execution operations (<code>tools/call</code>, <code>resources/read</code>, <code>prompts/get</code>), blocking operations that are not authorized by the defined policies.</p> <pre><code>sequenceDiagram\n    participant MCPClient as MCP Client\n    participant EunomiaMiddleware as Eunomia Middleware\n    participant MCPServer as FastMCP Server\n    participant EunomiaServer as Eunomia Server\n\n    MCPClient-&gt;&gt;EunomiaMiddleware: MCP Execution Request (e.g., tools/call)\n    EunomiaMiddleware-&gt;&gt;EunomiaServer: Authorization Check\n    EunomiaServer-&gt;&gt;EunomiaMiddleware: Authorization Decision\n    EunomiaMiddleware--&gt;&gt;MCPClient: MCP Unauthorized Error (if denied)\n    EunomiaMiddleware-&gt;&gt;MCPServer: MCP Execution Request (if allowed)\n    MCPServer--&gt;&gt;EunomiaMiddleware: MCP Execution Response (if allowed)\n    EunomiaMiddleware--&gt;&gt;MCPClient: MCP Execution Response (if allowed)</code></pre>"},{"location":"mcp_middleware/#installation","title":"Installation","text":"<pre><code>pip install eunomia-mcp\n</code></pre>"},{"location":"mcp_middleware/#user-workflows","title":"User Workflows","text":"<p>Choose your path based on what you want to accomplish:</p> <ul> <li>\ud83d\ude80 Quickstart Guide: Add authorization to your MCP server in under 5 minutes</li> <li>\ud83d\udd27 Policy Configuration: Create and manage authorization policies using our CLI tools</li> <li>\ud83d\udc65 Agent Authentication: Customize agent identification</li> <li> <p>\ud83c\udfd7\ufe0f Advanced Features:</p> <ul> <li>Centralized PDP: Use a remote Eunomia server for centralized policy enforcement</li> <li>Use as Proxy Server: Use a proxy to add authorization to any remote MCP server</li> <li>Logging and monitoring: Enable audit logging and monitoring</li> </ul> </li> </ul>"},{"location":"mcp_middleware/authentication/","title":"Agent Authentication","text":"<p>Control how agents and users are identified and authenticated by your MCP server so that you can enforce policies on them.</p>"},{"location":"mcp_middleware/authentication/#default-agent-authentication","title":"Default Agent Authentication","text":"<p>Agents are identified through HTTP headers:</p> <pre><code>X-Agent-ID: claude\nX-User-ID: user123\nUser-Agent: Claude\nAuthorization: Bearer api-key-here\nContent-Type: application/json\n</code></pre>"},{"location":"mcp_middleware/authentication/#principal-extraction","title":"Principal Extraction","text":"<p>The middleware automatically extracts principals from these headers:</p> Header Principal URI Attributes <code>X-Agent-ID: claude</code> <code>agent:claude</code> <code>{\"agent_id\": \"claude\"}</code> <code>X-User-ID: user123</code> <code>{\"user_id\": \"user123\"}</code> <code>User-Agent: Claude</code> <code>{\"user_agent\": \"Claude\"}</code> <code>Authorization: Bearer xyz</code> <code>{\"api_key\": \"xyz\"}</code>"},{"location":"mcp_middleware/authentication/#custom-agent-authentication","title":"Custom Agent Authentication","text":""},{"location":"mcp_middleware/authentication/#custom-principal-extraction","title":"Custom Principal Extraction","text":"<p>For advanced authentication scenarios, you can subclass the <code>EunomiaMcpMiddleware</code> class and override the default principal extraction logic:</p> <pre><code>from eunomia_core import schemas\nfrom eunomia_mcp.middleware import EunomiaMcpMiddleware\nfrom fastmcp.server.dependencies import get_http_headers\n\n\nclass CustomAuthMiddleware(EunomiaMcpMiddleware):\n    def _extract_principal(self) -&gt; schemas.PrincipalCheck:\n        headers = get_http_headers()\n        token = headers.get(\"Authorization\", \"\").replace(\"Bearer \", \"\")\n\n        # Extract from JWT token\n        if token:\n            payload = decode_jwt(token)  # Your JWT decoding logic\n            return schemas.PrincipalCheck(\n                uri=f\"user:{payload['sub']}\",\n                attributes={\n                    \"role\": payload.get(\"role\"),\n                    \"department\": payload.get(\"dept\")\n                }\n            )\n\n        # Fallback to default\n        return super()._extract_principal()\n</code></pre>"},{"location":"mcp_middleware/authentication/#using-custom-authentication","title":"Using Custom Authentication","text":"<p>Integrate your custom authentication middleware:</p> <pre><code>from fastmcp import FastMCP\n\nmcp = FastMCP(\"Secure MCP Server \ud83d\udd12\")\n\n# Use your custom authentication\ncustom_middleware = CustomAuthMiddleware()\nmcp.add_middleware(custom_middleware)\n</code></pre>"},{"location":"mcp_middleware/policies/","title":"Configure Policies","text":"<p>Define fine-grained access control rules for your MCP server using JSON-based policies and CLI tools.</p>"},{"location":"mcp_middleware/policies/#policy-management-cli","title":"Policy Management CLI","text":"<p>Use the <code>eunomia-mcp</code> CLI in your terminal to manage your MCP authorization policies.</p>"},{"location":"mcp_middleware/policies/#creating-your-first-policy","title":"Creating Your First Policy","text":"<pre><code># Create a default policy configuration file\neunomia-mcp init\n\n# Create a custom policy configuration file from your FastMCP server instance\neunomia-mcp init --custom-mcp \"app.server:mcp\"\n\n# Generate both policy configuration file and a sample FastMCP server with Eunomia authorization\neunomia-mcp init --sample\n</code></pre> <p>You can edit the created <code>mcp_policies.json</code> policy configuration file to your liking. Refer to the templates for example policies and rules.</p>"},{"location":"mcp_middleware/policies/#validating-policies","title":"Validating Policies","text":"<pre><code># Validate your policy file\neunomia-mcp validate mcp_policies.json\n</code></pre>"},{"location":"mcp_middleware/policies/#deploying-policies","title":"Deploying Policies","text":"<p>Info</p> <p>This operation is needed only if you are using a remote Eunomia server, otherwise you can skip this step.</p> <pre><code># Push your policy to Eunomia server\neunomia-mcp push mcp_policies.json\n\n# Push your policy and overwrite existing ones\neunomia-mcp push mcp_policies.json --overwrite\n</code></pre>"},{"location":"mcp_middleware/policies/#workflow-summary","title":"Workflow Summary","text":"<ol> <li> <p>Initialize: <code>eunomia-mcp init</code></p> <p>Tip</p> <p>Use <code>--custom-mcp</code> for a policy customized for your MCP server!</p> </li> <li> <p>Customize: Edit generated policy file</p> </li> <li>Validate: <code>eunomia-mcp validate mcp_policies.json</code></li> <li>Run: Run your MCP server with middleware</li> </ol> <p>When using a remote Eunomia server, you need to deploy the policy to it:</p> <p>\u2192 Deploy: <code>eunomia-mcp push mcp_policies.json</code> \u2192 Run</p>"},{"location":"mcp_middleware/policies/#mcp-context-extraction","title":"MCP Context Extraction","text":""},{"location":"mcp_middleware/policies/#methods-mapping","title":"Methods Mapping","text":"<p>The middleware automatically maps MCP methods to authorization checks:</p> MCP Method Resource URI Action Middleware behavior <code>tools/list</code> <code>mcp:tools:{name}</code> <code>list</code> Filters the server's response <code>tools/call</code> <code>mcp:tools:{name}</code> <code>execute</code> Blocks/forwards the request to the server <code>resources/list</code> <code>mcp:resources:{name}</code> <code>list</code> Filters the server's response <code>resources/read</code> <code>mcp:resources:{name}</code> <code>execute</code> Blocks/forwards the request to the server <code>prompts/list</code> <code>mcp:prompts:{name}</code> <code>list</code> Filters the server's response <code>prompts/get</code> <code>mcp:prompts:{name}</code> <code>execute</code> Blocks/forwards the request to the server"},{"location":"mcp_middleware/policies/#contextual-attributes","title":"Contextual Attributes","text":"<p>The middleware extracts contextual attributes from the MCP request and passes them to the decision engine; these attributes can therefore be referenced inside policies to define dynamic rules.</p> Attribute Type Description Sample value <code>method</code> <code>str</code> The MCP method <code>tools/list</code> <code>component_type</code> <code>str</code> The type of component: <code>tools</code>, <code>resources</code> or <code>prompts</code> <code>tools</code> <code>name</code> <code>str</code> The name of the component <code>file_read</code> <code>uri</code> <code>str</code> The MCP URI of the component <code>mcp:tools:file_read</code> <code>arguments</code> <code>dict</code> (Optional) The arguments of the execution operation <code>{\"path\": \"file.txt\"}</code> <p>You now have an MCP server with authorization that enforces customized policies. Explore agent authentication to further secure your server.</p>"},{"location":"mcp_middleware/quickstart/","title":"Quickstart","text":"<p>Get your MCP server secured with authorization in under 5 minutes.</p>"},{"location":"mcp_middleware/quickstart/#step-1-install-the-middleware","title":"Step 1: Install the Middleware","text":"<pre><code>pip install eunomia-mcp\n</code></pre>"},{"location":"mcp_middleware/quickstart/#step-2-add-middleware-to-your-server","title":"Step 2: Add Middleware to Your Server","text":"server.py<pre><code>from fastmcp import FastMCP\nfrom eunomia_mcp import create_eunomia_middleware\n\n# Create your FastMCP server\nmcp = FastMCP(\"Secure MCP Server \ud83d\udd12\")\n\n@mcp.tool()\ndef add(a: int, b: int) -&gt; int:\n    \"\"\"Add two numbers\"\"\"\n    return a + b\n\n# Add middleware to your server\nmiddleware = create_eunomia_middleware(policy_file=\"mcp_policies.json\")\nmcp.add_middleware(middleware)\n\nif __name__ == \"__main__\":\n    mcp.run()\n</code></pre>"},{"location":"mcp_middleware/quickstart/#step-3-use-your-server","title":"Step 3: Use Your Server","text":"<p>You can now run your MCP server normally:</p> <pre><code>python server.py\n</code></pre> <p>Your server now has authorization middleware! By default, all requests will be denied until you configure policies.</p>"},{"location":"mcp_middleware/advanced/as-proxy/","title":"Authorize Remote MCP Servers using a Proxy","text":"<p>You can use the Eunomia MCP Middleware even if you are connecting to remote MCP servers that you don't control.</p> <p>To do so, you can use a proxy MCP server that will forward the requests to the remote servers and apply the Eunomia MCP Middleware within the proxy server.</p> <pre><code>from eunomia_mcp import create_eunomia_middleware\nfrom fastmcp import FastMCP\n\nconfig = {\n    \"mcpServers\": {\n        \"default\": {\n            \"command\": \"npx\",\n            \"args\": [\"-y\", \"mcp-remote\", \"https://mcp.example.com/v1/sse\"],\n        }\n    }\n}\n\nproxy = FastMCP.as_proxy(config, name=\"Proxy with Eunomia Middleware\")\n\nmiddleware = create_eunomia_middleware()\nproxy.add_middleware(middleware)\n\nif __name__ == \"__main__\":\n    proxy.run()\n</code></pre>"},{"location":"mcp_middleware/advanced/centralized-pdp/","title":"Centralize Policy Enforcement with a Remote Eunomia Server","text":"<p>The Eunomia MCP Middleware can be configured to use an embedded Eunomia server within the MCP server (default) or a remote Eunomia server.</p> <p>The remote option is useful if you want to have a centralized policy decision point for multiple MCP servers, which is especially relevant in enterprise scenarios.</p> <p>Info</p> <p>You can run the Eunomia server in the background with Docker:</p> <pre><code>docker run -d -p 8421:8421 --name eunomia ttommitt/eunomia-server:latest\n</code></pre> <p>Or refer to this documentation for additional running options.</p> <p>Then, you can configure the middleware to use the remote Eunomia server:</p> <pre><code>from eunomia_mcp import create_eunomia_middleware\n\nmiddleware = create_eunomia_middleware(\n    use_remote_eunomia=True,\n    eunomia_endpoint=\"http://localhost:8421\",\n)\n</code></pre>"},{"location":"mcp_middleware/advanced/centralized-pdp/#middleware-configuration","title":"Middleware Configuration","text":"<p>The <code>create_eunomia_middleware</code> function accepts the following parameters:</p> Parameter Type Default Description <code>policy_file</code> <code>str</code> <code>mcp_policies.json</code> Path to policy configuration JSON file, for embedded Eunomia server only <code>use_remote_eunomia</code> <code>bool</code> <code>False</code> Whether to use a remote Eunomia server <code>eunomia_endpoint</code> <code>str</code> <code>http://localhost:8421</code> Eunomia server URL, for remote Eunomia server only <code>enable_audit_logging</code> <code>bool</code> <code>True</code> Enable request/violation logging"},{"location":"mcp_middleware/advanced/logging/","title":"Logging & Monitoring","text":""},{"location":"mcp_middleware/advanced/logging/#audit-logging","title":"Audit Logging","text":"<p>Enable comprehensive audit trails:</p> <pre><code>import logging\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(\"eunomia_mcp\")\n\n# Authorization success\n# INFO: Authorized request | MCP method: tools/call | MCP uri: mcp:tools:file_read | User-Agent: Claude\n\n# Authorization violation\n# WARNING: Authorization violation: Access denied for tools/call | MCP method: tools/call | MCP uri: mcp:tools:file_read | User-Agent: Claude\n</code></pre>"},{"location":"mcp_middleware/advanced/logging/#log-categories","title":"Log Categories","text":"<ul> <li>INFO: Successful authorization decisions</li> <li>WARNING: Authorization violations</li> <li>ERROR: System errors (Eunomia server issues, etc.)</li> </ul>"},{"location":"server/","title":"Welcome to Eunomia","text":""},{"location":"server/#what-is-eunomia","title":"What is Eunomia?","text":"<p>Eunomia is a Python library that allows you to decouple the authorization logic from the main architecture of your AI Agent. Eunomia is built as a standalone authorization server that can serve any application.</p> <p>It is built and maintained by What About You, while contributions are welcome from the community.</p> <p>Warning</p> <p>Eunomia is currently under active development and therefore subject to change.</p>"},{"location":"server/#core-components","title":"Core Components","text":"<ul> <li> <p> Principals</p> <p>Principals are actors (human or AI) performing actions on resources.</p> </li> <li> <p> Resources</p> <p>Resources are the targets of actions, including data, tools, and AI agents.</p> </li> <li> <p> Attributes</p> <p>Metadata of Principals and Resources, used in authorization policies.</p> </li> <li> <p> Policies</p> <p>Policies are rules that explicitly allow or deny Principals' actions on Resources.</p> </li> </ul>"},{"location":"server/#why-eunomia","title":"Why Eunomia?","text":"<p>Traditional authorization layers, focused on user-resource separation, become obsolete with AI agents. These agents, both autonomous and controllable, necessitate a new permission paradigm.</p> <p>The ability for agents to access tools\u2014executable actions beyond static data\u2014and initiate interactions with other agents introduced policy requirements that legacy systems couldn't meet. This duality demands dynamic yet deterministic boundaries that adapt to context, reflecting their role as both actor and resource.</p> <p>We aim to solve this with Eunomia, an open-source, developer-oriented authorization framework that:</p> <ul> <li>Makes it possible to consider agents as both actors and resources</li> <li>Enforces dynamic yet deterministic policies based on static and contextual attributes</li> <li>Enables leaner agent architectures with decoupled authorization logic</li> <li>Preserves agent decision-making while enforcing security</li> </ul>"},{"location":"server/installation/","title":"Installation","text":""},{"location":"server/installation/#install-eunomia","title":"Install Eunomia","text":""},{"location":"server/installation/#install-latest-release","title":"Install latest release","text":"<p>You can install the latest release of <code>eunomia</code> with <code>pip</code>:</p> <pre><code>pip install eunomia-ai\n</code></pre>"},{"location":"server/installation/#install-for-development","title":"Install for development","text":"<p>See the contributing documentation for instructions on how to install <code>eunomia</code> for development.</p>"},{"location":"server/installation/#install-sdks","title":"Install SDKs","text":"<p>All SDKs are published as separate packages, explore the available SDKs and follow the specific installation instructions for each.</p>"},{"location":"server/quickstart/","title":"Quickstart","text":"<p>After installing Eunomia, you can start using it by following this quickstart example.</p>"},{"location":"server/quickstart/#access-control-for-multi-agent-architecture","title":"Access Control for Multi-Agent Architecture","text":"<p>Let's assume you have a multi-agent system where an orchestrator routes the user requests to one of the available agents that can perform a specific task. You want to allow a user to access only a specific set of the agents based on their attributes.</p> <p>Particulary, let's say that access to the IT Desk Agent is restricted to employess in the IT department, while access to the HR Agent is restricted to managers in the HR department.</p>"},{"location":"server/quickstart/#server-setup","title":"Server Setup","text":"<p>Start the Eunomia server with:</p> <pre><code>eunomia server\n</code></pre>"},{"location":"server/quickstart/#policy-configuration","title":"Policy Configuration","text":"<p>Now, you need to create a policy that will be used to enforce the access control. The policy will contain two rules:</p> <ol> <li>Allow access to the resource with attributes <code>agent-id == it-desk-agent</code> to principals with the <code>department == it</code>.</li> <li>Allow access to the resource with attributes <code>agent-id == hr-agent</code> to principals with the <code>department == hr</code> AND the <code>role == manager</code>.</li> </ol> <p>You can use the <code>POST /admin/policies/simple</code> endpoint for this.</p> PythoncURLOutput <pre><code>from eunomia_core.schemas import CheckRequest, PrincipalCheck, ResourceCheck\nfrom eunomia_sdk import EunomiaClient\n\neunomia = EunomiaClient()\n\neunomia.create_simple_policy(\n    CheckRequest(\n        principal=PrincipalCheck(attributes={\"department\": \"it\"}),\n        resource=ResourceCheck(attributes={\"agent-id\": \"it-desk-agent\"}),\n        action=\"access\",\n    ),\n    name=\"it-desk-policy\",\n)\n\neunomia.create_simple_policy(\n    CheckRequest(\n        principal=PrincipalCheck(attributes={\"department\": \"hr\", \"role\": \"manager\"}),\n        resource=ResourceCheck(attributes={\"agent-id\": \"hr-agent\"}),\n        action=\"access\",\n    ),\n    name=\"hr-policy\",\n)\n</code></pre> <p>Info</p> <p>To use the Python SDK, check out its documentation for installation instructions.</p> <pre><code>curl -X POST 'http://localhost:8421/admin/policies/simple?name=it-desk-policy' \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"principal\": {\"attributes\": {\"department\": \"it\"}}, \"resource\": {\"attributes\": {\"agent-id\": \"it-desk-agent\"}}, \"action\": \"access\"}'\n\ncurl -X POST 'http://localhost:8421/admin/policies/simple?name=hr-policy' \\\n  -H \"Content-Type: application/json\" \\\n  -d '{\"principal\": {\"attributes\": {\"department\": \"hr\", \"role\": \"manager\"}}, \"resource\": {\"attributes\": {\"agent-id\": \"hr-agent\"}}, \"action\": \"access\"}'\n</code></pre> <pre><code>{\n    \"version\": \"1.0\",\n    \"name\":\"it-desk-policy\",\n    \"description\": null,\n    \"rules\":[\n        {\n            \"name\": \"it-desk-policy\",\n            \"effect\": \"allow\",\n            \"principal_conditions\": [{\"path\": \"attributes.department\", \"operator\": \"==\", \"value\": \"it\"}],\n            \"resource_conditions\": [{\"path\": \"attributes.agent-id\", \"operator\": \"==\", \"value\": \"it-desk-agent\"}],\n            \"actions\": [\"access\"]\n        }\n    ],\n    \"default_effect\": \"deny\"\n}\n\n{\n    \"version\": \"1.0\",\n    \"name\":\"hr-policy\",\n    \"description\": null,\n    \"rules\":[\n        {\n            \"name\": \"hr-policy\",\n            \"effect\": \"allow\",\n            \"principal_conditions\": [{\"path\": \"attributes.department\", \"operator\": \"==\", \"value\": \"hr\"}, {\"path\": \"attributes.role\", \"operator\": \"==\", \"value\": \"manager\"}],\n            \"resource_conditions\": [{\"path\": \"attributes.agent-id\", \"operator\": \"==\", \"value\": \"hr-agent\"}],\n            \"actions\": [\"access\"]\n        },\n    ],\n    \"default_effect\": \"deny\"\n}\n</code></pre>"},{"location":"server/quickstart/#policy-enforcement","title":"Policy Enforcement","text":"<p>Now, you can enforce the policies in your application at runtime by checking the access of a given principal to a specific resource.</p> <p>You can use the <code>POST /check</code> endpoint for this, passing the principal and resource identifiers and their attributes.</p> PythoncURLOutput <pre><code># allowed access\neunomia.check(\n    resource_attributes={\"agent-id\": \"it-desk-agent\"},\n    principal_attributes={\"department\": \"it\"},\n)\neunomia.check(\n    resource_attributes={\"agent-id\": \"hr-agent\"},\n    principal_attributes={\"department\": \"hr\", \"role\": \"manager\"},\n)\n# denied access\neunomia.check(\n    resource_attributes=\"it-desk-agent\",\n    principal_attributes={\"department\": \"sales\"},\n)\neunomia.check(\n    resource_attributes=\"hr-agent\",\n    principal_attributes={\"department\": \"hr\", \"role\": \"analyst\"},\n)\n</code></pre> <pre><code># allowed access\ncurl -X POST 'http://localhost:8421/check' -H \"Content-Type: application/json\" -d '{\"resource\": {\"attributes\": {\"agent-id\": \"it-desk-agent\"}}, \"principal\": {\"attributes\": {\"department\": \"it\"}}}'\ncurl -X POST 'http://localhost:8421/check' -H \"Content-Type: application/json\" -d '{\"resource\": {\"attributes\": {\"agent-id\": \"hr-agent\"}}, \"principal\": {\"attributes\": {\"department\": \"hr\", \"role\": \"manager\"}}}'\n# denied access\ncurl -X POST 'http://localhost:8421/check' -H \"Content-Type: application/json\" -d '{\"resource\": {\"attributes\": {\"agent-id\": \"it-desk-agent\"}}, \"principal\": {\"attributes\": {\"department\": \"sales\"}}}'\ncurl -X POST 'http://localhost:8421/check' -H \"Content-Type: application/json\" -d '{\"resource\": {\"attributes\": {\"agent-id\": \"hr-agent\"}}, \"principal\": {\"attributes\": {\"department\": \"hr\", \"role\": \"analyst\"}}}'\n</code></pre> <pre><code># allowed access\n{\"allowed\":true, \"reason\":\"Rule it-desk-policy allowed the action in policy it-desk-policy\"}\n{\"allowed\":true, \"reason\":\"Rule hr-policy allowed the action in policy hr-policy\"}\n# denied access\n{\"allowed\":false, \"reason\":\"Action denied by default effect\"}\n{\"allowed\":false, \"reason\":\"Action denied by default effect\"}\n</code></pre> <p>Congratulations! You've just made your first steps with Eunomia.</p> <p>You can now explore the user guide to learn more about Eunomia or explore the API documentation for more details on how to use Eunomia in your application.</p>"},{"location":"server/fetchers/","title":"What are Dynamic Fetchers","text":"<p>Dynamic Fetchers are pluggable components in Eunomia that retrieve entity attributes at runtime. They enable the authorization server to gather metadata about principals and resources from various sources when making policy decisions.</p> <p>Dynamic Fetchers implement the <code>fetch_attributes(uri: str)</code> method to retrieve attributes for entities identified by their URI. Unlike static attributes that are pre-configured, dynamic fetchers allow Eunomia to pull fresh metadata from external systems, databases, or APIs during the authorization process.</p> <p>This dynamic approach enables:</p> <ul> <li>Real-time attribute retrieval: Get the latest entity metadata when evaluating policies</li> <li>External system integration: Connect to databases, APIs, or other services for attribute data</li> <li>Flexible architecture: Plug in custom fetchers for any use case</li> </ul>"},{"location":"server/fetchers/#configuration","title":"Configuration","text":"<p>Dynamic Fetchers can be configured through the <code>FETCHERS</code> variable in your Eunomia settings, which can be passed as an environment variable:</p> <pre><code>FETCHERS = {\"registry\": {...}, \"passport\": {...}}\n</code></pre>"},{"location":"server/fetchers/#built-in-fetchers","title":"Built-in Fetchers","text":"<p>Eunomia comes with some built-in fetchers:</p> Fetcher Name Description Jump to Entity Registry <code>registry</code> Stores and retrieves entity attributes in a SQL database  Page Agent Passport <code>passport</code> Enables agent authentication through encrypted JWT tokens  Page"},{"location":"server/fetchers/#creating-a-custom-fetcher","title":"Creating a Custom Fetcher","text":"<p>To create a custom fetcher, you need to subclass the <code>BaseFetcher</code> class and implement the <code>fetch_attributes(uri: str)</code> method.</p> <pre><code>from eunomia.fetchers.base import BaseFetcher, BaseFetcherConfig\n\n\nclass CustomFetcherConfig(BaseFetcherConfig):\n    pass\n\n\nclass CustomFetcher(BaseFetcher):\n    config: CustomFetcherConfig\n\n    async def fetch_attributes(self, uri: str) -&gt; dict:\n        # your custom logic here\n        return {}\n</code></pre> <p>Then, you can register the fetcher within the <code>FetcherFactory</code> to make it available for use:</p> <pre><code>from eunomia.fetchers.factory import FetcherFactory\n\nFetcherFactory.register_fetcher(\n    \"custom\",\n    CustomFetcher,\n    CustomFetcherConfig,\n)\n</code></pre>"},{"location":"server/fetchers/passport/","title":"Agent Passport","text":"<p>The Agent Passport enables trusted agent governance by providing cryptographically verified agent identities. Agents present signed JWT tokens that prove their identity and attributes, allowing Eunomia to make authorization decisions based on verified agent information rather than self-reported claims.</p>"},{"location":"server/fetchers/passport/#what-is-the-agent-passport","title":"What is the Agent Passport?","text":"<p>Agent Passport provides verified agent identity for governance through:</p> <ul> <li>Cryptographically Signed Identity: JWT tokens prove agent authenticity through digital signatures</li> <li>Tamper-Proof Attributes: Agent attributes are embedded in signed tokens, preventing false claims</li> <li>Verified Authorization Context: Policies can trust agent identity and attributes for authorization decisions</li> <li>Admin-Controlled Identity: Controlled token issuance ensures only authorized agents receive identity tokens</li> </ul> <p>Technically, Agent Passport implements this as a Dynamic Fetcher that decodes JWT tokens to extract verified agent attributes during policy evaluation.</p>"},{"location":"server/fetchers/passport/#how-it-works","title":"How it Works","text":"<ol> <li>Passport Issuance: Admins issue encrypted passport tokens for agents through the API</li> <li>Agent Authentication: Agents present their passport token as the <code>uri</code> parameter during permission checks</li> <li>Automatic Verification: The fetcher verifies the token signature and extracts the embedded attributes</li> <li>Policy Evaluation: The decrypted attributes are passed to the policy engine for authorization decisions</li> </ol>"},{"location":"server/fetchers/passport/#configuration","title":"Configuration","text":"<p>Configure the Passport fetcher in your Eunomia settings:</p> <pre><code>FETCHERS = {\n    \"passport\": {\n        \"jwt_secret\": \"your-secret-key\",\n        \"jwt_algorithm\": \"HS256\", # optional\n        \"jwt_issuer\": \"eunomia\", # optional\n        \"jwt_default_ttl\": 7200,  # optional, 2 hours\n        \"requires_registry\": False,  # optional, set to True to require agents to be registered\n        \"entity_type\": None  # optional, set to \"principal\" to only require principals to use the passport\n    }\n}\n</code></pre> <p>When <code>requires_registry</code> is enabled, the passport fetcher will only issue tokens for agents that are already registered in the registry fetcher.</p>"},{"location":"server/fetchers/passport/#user-guides","title":"User Guides","text":"Guide Description Jump to Issue a Passport Learn how to issue passport tokens for agents  Page"},{"location":"server/fetchers/passport/issue_passport/","title":"Issue a Passport","text":"<p>Passport issuance is an admin operation that creates JWT tokens for agents to authenticate with Eunomia. These tokens can contain the agent's attributes and can be used during permission checks.</p>"},{"location":"server/fetchers/passport/issue_passport/#prerequisites","title":"Prerequisites","text":"<ul> <li>Eunomia server running with the Passport fetcher configured</li> <li>Admin API access</li> <li>If <code>requires_registry</code> is enabled, the agent must be registered in the registry first</li> </ul>"},{"location":"server/fetchers/passport/issue_passport/#issue-a-passport-via-api","title":"Issue a Passport via API","text":""},{"location":"server/fetchers/passport/issue_passport/#endpoint","title":"Endpoint","text":"<pre><code>POST /fetchers/passport/issue\n</code></pre>"},{"location":"server/fetchers/passport/issue_passport/#request-body","title":"Request Body","text":"<pre><code>{\n  \"uri\": \"agent://my-ai-agent\",\n  \"attributes\": {\n    \"role\": \"assistant\",\n    \"department\": \"customer-service\",\n    \"capabilities\": [\"chat\", \"search\"]\n  },\n  \"ttl\": 3600\n}\n</code></pre>"},{"location":"server/fetchers/passport/issue_passport/#parameters","title":"Parameters","text":"Parameter Type Required Description <code>uri</code> string Yes The unique identifier for the agent <code>attributes</code> object No Additional attributes to embed in the passport <code>ttl</code> integer No Token lifetime in seconds (defaults to configured <code>jwt_default_ttl</code>)"},{"location":"server/fetchers/passport/issue_passport/#response","title":"Response","text":"<pre><code>{\n  \"passport\": \"eyJhbGciOiJIU...\",\n  \"passport_id\": \"psp_a1b2c3d4e5f6\",\n  \"expires_in\": 3600\n}\n</code></pre>"},{"location":"server/fetchers/passport/issue_passport/#example-usage","title":"Example Usage","text":"PythoncURLOutput <pre><code>from eunomia_sdk import EunomiaClient\n\neunomia = EunomiaClient()\n\nresponse = eunomia.issue_passport(\n    uri=\"agent://customer-service-bot\",\n    attributes={\n        \"role\": \"customer_support\",\n        \"access_level\": \"standard\",\n        \"department\": \"support\",\n    },\n    ttl=7200,\n)\n</code></pre> <pre><code>curl -X POST \"http://localhost:8421/fetchers/passport/issue\" \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\n        \"uri\": \"agent://customer-service-bot\",\n        \"attributes\": {\n            \"role\": \"customer_support\",\n            \"access_level\": \"standard\",\n            \"department\": \"support\"\n        },\n        \"ttl\": 7200\n    }'\n</code></pre> <pre><code>{\n    \"passport\": \"eyJhbGciOiJIU...\",\n    \"passport_id\": \"psp_849fc4eddefa\",\n    \"expires_in\": 7200\n}\n</code></pre>"},{"location":"server/fetchers/passport/issue_passport/#using-the-passport","title":"Using the Passport","text":"<p>Once issued, agents can use the passport token as their URI when making permission checks:</p> <pre><code># Agent uses the passport token as their URI\nresult = eunomia.check(\n    principal_uri=passport_token,\n    resource_uri=\"customer_data\",\n    action=\"read\",\n)\n</code></pre>"},{"location":"server/fetchers/passport/issue_passport/#registry-integration","title":"Registry Integration","text":"<p>When <code>requires_registry = true</code> is set in the server settings, the passport issuer will:</p> <ol> <li>Check if the agent URI exists in the registry</li> <li>Automatically include registry attributes in the passport</li> <li>Deny issuance if the agent is not registered</li> </ol> <pre><code># If requires_registry=True, this will fail unless the agent is registered\nresponse = eunomia.issue_passport(uri=\"agent://unregistered-agent\")\n</code></pre>"},{"location":"server/fetchers/registry/","title":"Entity Registry","text":"<p>The Registry fetcher is a built-in Dynamic Fetcher that stores and retrieves entity attributes in a SQL database. It provides a persistent storage solution for entity metadata that can be accessed during policy evaluation.</p>"},{"location":"server/fetchers/registry/#what-is-the-registry-fetcher","title":"What is the Registry Fetcher?","text":"<p>The Registry fetcher allows you to:</p> <ul> <li>Store entity attributes: Register principals and resources with their metadata</li> <li>Retrieve attributes: Fetch entity attributes at runtime during authorization checks</li> <li>Manage entities: Update and delete entity information through REST API endpoints</li> </ul> <p>The Registry fetcher is ideal for scenarios where you want to maintain entity metadata within your Eunomia deployment, providing fast access and full control over your authorization data.</p>"},{"location":"server/fetchers/registry/#configuration","title":"Configuration","text":"<p>Configure the Registry fetcher in your Eunomia settings:</p> <pre><code>FETCHERS = {\n    \"registry\": {\n        \"sql_database_url\": \"sqlite:///./.db/eunomia_db.sqlite\", # or any other SQL database URL\n        \"entity_type\": None  # optional\n    }\n}\n</code></pre>"},{"location":"server/fetchers/registry/#user-guides","title":"User Guides","text":"Guide Description Jump to Register an Entity Learn how to register new entities with their attributes  Page Update and Delete an Entity Learn how to update or delete existing entities  Page"},{"location":"server/fetchers/registry/register_entities/","title":"Register an Entity","text":"<p>In the Quickstart guide, we showed how to use the <code>POST /check</code> endpoint to verify if a given principal can perform an action on a specific resource by passing their identifiers and attributes. While this approach is straightforward, it requires sending all attributes with each check request. For more complex scenarios, it can be more efficient to pre-register the attributes of principals and resources, and then reference them by their identifier at runtime.</p>"},{"location":"server/fetchers/registry/register_entities/#register-a-new-entity","title":"Register a New Entity","text":"<p>You can register a new entity using the <code>POST /admin/fetchers/registry/entities</code> endpoint. This endpoint accepts a POST request with a JSON payload that follows the EntityCreate schema. Upon successful registration, the server returns the entity's information as defined by the EntityInDb model.</p>"},{"location":"server/fetchers/registry/register_entities/#payload-requirements","title":"Payload Requirements","text":"<p>Your JSON payload must include the following fields:</p> <ul> <li> <p><code>attributes</code> (required):   An array of attribute objects. Each attribute must include:</p> </li> <li> <p><code>key</code> (string): The attribute's key.</p> </li> <li><code>value</code> (string): The attribute's value.</li> </ul> <p>Note: The attributes array must not be empty, and duplicate keys are not allowed.</p> <ul> <li> <p><code>type</code> (required):   The type of the entity, defined by the EntityType enum (i.e., <code>principal</code> or <code>resource</code>).</p> </li> <li> <p><code>uri</code> (optional):   A unique identifier for the entity. If omitted, the server will generate one automatically. This identifier is used later to check permissions for the entity.</p> </li> </ul>"},{"location":"server/fetchers/registry/register_entities/#response-details","title":"Response Details","text":"<p>On success, the server responds with a JSON object that includes the <code>uri</code> of the entity, which can be stored locally and used at a later stage.</p>"},{"location":"server/fetchers/registry/register_entities/#example-usage","title":"Example Usage","text":"PythoncURLOutput <pre><code>from eunomia_core import enums\nfrom eunomia_sdk import EunomiaClient\n\neunomia = EunomiaClient()\n\n# Register a resource with metadata\nresource = eunomia.register_entity(\n    type=enums.EntityType.resource,\n    attributes={\n        \"name\": \"sensitive_document\",\n        \"type\": \"document\",\n        \"classification\": \"confidential\"\n    }\n)\nprint(\"Resource:\", resource)\n\n# Register a principal with metadata\nprincipal = eunomia.register_entity(\n    type=enums.EntityType.principal,\n    attributes={\n        \"name\": \"user_123\",\n        \"role\": \"analyst\",\n        \"department\": \"research\"\n    }\n)\nprint(\"Principal:\", principal)\n</code></pre> <pre><code>curl -X POST 'http://localhost:8421/admin/fetchers/registry/entities' \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\n           \"type\": \"resource\",\n           \"attributes\": {\n             \"name\": \"sensitive_document\",\n             \"type\": \"document\",\n             \"classification\": \"confidential\"\n           }\n         }'\n\ncurl -X POST 'http://localhost:8421/admin/fetchers/registry/entities' \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\n           \"type\": \"principal\",\n           \"attributes\": {\n             \"name\": \"user_123\",\n             \"role\": \"analyst\",\n             \"department\": \"research\"\n           }\n         }'\n</code></pre> <pre><code># Example JSON response for a resource\n{\n  \"uri\": \"generated-uri-123\",\n  \"attributes\": [\n      {\n        \"key\": \"name\",\n        \"value\": \"sensitive_document\",\n        \"registered_at\": \"2025-03-22T10:00:00Z\",\n        \"updated_at\": \"2025-03-22T10:00:00Z\"\n      },\n      {\n        \"key\": \"type\",\n        \"value\": \"document\",\n        \"registered_at\": \"2025-03-22T10:00:00Z\",\n        \"updated_at\": \"2025-03-22T10:00:00Z\"\n      },\n      {\n        \"key\": \"classification\",\n        \"value\": \"confidential\",\n        \"registered_at\": \"2025-03-22T10:00:00Z\",\n        \"updated_at\": \"2025-03-22T10:00:00Z\"\n      }\n  ],\n  \"registered_at\": \"2025-03-22T10:00:00Z\"\n}\n\n# Example JSON response for a principal\n{\n  \"uri\": \"generated-uri-456\",\n  \"attributes\": [\n      {\n        \"key\": \"name\",\n        \"value\": \"user_123\",\n        \"registered_at\": \"2025-03-22T10:01:00Z\",\n        \"updated_at\": \"2025-03-22T10:01:00Z\"\n      },\n      {\n        \"key\": \"role\",\n        \"value\": \"analyst\",\n        \"registered_at\": \"2025-03-22T10:01:00Z\",\n        \"updated_at\": \"2025-03-22T10:01:00Z\"\n      },\n      {\n        \"key\": \"department\",\n        \"value\": \"research\",\n        \"registered_at\": \"2025-03-22T10:01:00Z\",\n        \"updated_at\": \"2025-03-22T10:01:00Z\"\n      }\n  ],\n  \"registered_at\": \"2025-03-22T10:01:00Z\"\n}\n</code></pre>"},{"location":"server/fetchers/registry/update_delete_entities/","title":"Update and Delete an Entity","text":"<p>In addition to registering entities, you can update or delete them using dedicated API endpoints. This section explains how to update an entity's attributes and remove an entity entirely.</p>"},{"location":"server/fetchers/registry/update_delete_entities/#update-an-entity","title":"Update an Entity","text":"<p>The <code>PUT /admin/fetchers/registry/entities/{uri}</code> endpoint allows you to update an already registered entity. The JSON payload must conform to the EntityUpdate schema. In this schema:</p> <ul> <li><code>uri</code> (required):   The unique identifier for the entity that you want to update.</li> <li> <p><code>attributes</code> (required):   An array of attribute objects to update. Each attribute must include a <code>key</code> and a <code>value</code></p> </li> <li> <p><code>override</code> (default: <code>False</code>), controls whether the update should completely override existing attributes or merge with them. If override is set to <code>True</code>, only the attributes and the respective values present in the <code>attributes</code> array will be present in the new updated entity. All the previous attributes will be overwritten.</p> </li> </ul>"},{"location":"server/fetchers/registry/update_delete_entities/#delete-an-entity","title":"Delete an Entity","text":"<p>The <code>DELETE /admin/fetchers/registry/entities/{uri}</code> endpoint allows you to delete an entity by providing its unique <code>uri</code>.</p>"},{"location":"server/fetchers/registry/update_delete_entities/#example-usage","title":"Example Usage","text":"PythoncURLOutput <pre><code>from eunomia_sdk import EunomiaClient\n\neunomia = EunomiaClient()\n\n# Update an entity's attributes\nupdated_entity = eunomia.update_entity(\n    type=\"resource\",  # Optional: if not provided, defaults to \"any\"\n    attributes={\n        \"name\": \"sensitive_document_updated\",\n        \"type\": \"document\",\n        \"classification\": \"confidential\"\n    },\n    uri=\"generated-uri-123\"  # The unique identifier of the entity to update\n)\nprint(\"Updated Entity:\", updated_entity)\n\n# Delete an entity\ndelete_response = eunomia.delete_entity(uri=\"generated-uri-123\")\nprint(\"Delete Response:\", delete_response)\n</code></pre> <pre><code># Update an entity\ncurl -X PUT 'http://localhost:8421/admin/fetchers/registry/entities/generated-uri-123' \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\n           \"uri\": \"generated-uri-123\",\n           \"type\": \"any\",\n           \"attributes\": {\n             \"name\": \"sensitive_document_updated\",\n             \"type\": \"document\",\n             \"classification\": \"confidential\"\n           }\n         }'\n\n# Delete an entity\ncurl -X DELETE 'http://localhost:8421/admin/fetchers/registry/entities/generated-uri-123' \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"uri\": \"generated-uri-123\"}'\n</code></pre> <pre><code># Example JSON response for an updated entity\n{\n  \"uri\": \"generated-uri-123\",\n  \"attributes\": [\n      {\n        \"key\": \"name\",\n        \"value\": \"sensitive_document_updated\",\n        \"registered_at\": \"2025-03-22T10:00:00Z\",\n        \"updated_at\": \"2025-03-22T11:00:00Z\"\n      },\n      {\n        \"key\": \"type\",\n        \"value\": \"document\",\n        \"registered_at\": \"2025-03-22T10:00:00Z\",\n        \"updated_at\": \"2025-03-22T11:00:00Z\"\n      },\n      {\n        \"key\": \"classification\",\n        \"value\": \"confidential\",\n        \"registered_at\": \"2025-03-22T10:00:00Z\",\n        \"updated_at\": \"2025-03-22T11:00:00Z\"\n      }\n  ],\n  \"registered_at\": \"2025-03-22T10:00:00Z\"\n}\n\n# Example JSON response for a deleted entity\n{\n  \"uri\": \"generated-uri-123\",\n  \"message\": \"Entity deleted successfully\"\n}\n</code></pre>"},{"location":"server/pdp/","title":"How Eunomia works","text":"<p>Eunomia is a standalone authorization server that can be integrated into any application. It follows a client-server architecture where the server handles all authorization logic, while clients interact with it through a REST API or available SDKs.</p> <p></p>"},{"location":"server/pdp/#architecture-overview","title":"Architecture Overview","text":"<p>Eunomia uses a decoupled architecture consisting of two main components:</p> <ol> <li> <p>Server: A standalone service that manages authorization policies, storing metadata for principals and resources, and making access control decisions. The server exposes a REST API.</p> </li> <li> <p>Client: A component integrated into your application that communicates with the Eunomia server. You can interact with the server either directly through HTTP requests or by using one of the provided SDKs for a more streamlined experience.</p> </li> </ol>"},{"location":"server/pdp/#authorization-workflow","title":"Authorization Workflow","text":"<p>Working with Eunomia involves two distinct phases:</p>"},{"location":"server/pdp/#policy-configuration-phase","title":"Policy Configuration Phase","text":"<p>In this phase, you configure the authorization policies that will govern access control in your application based on principals and resources attributes.</p> <p>For example, you might register an AI agent as a resource with its capabilities as metadata, and register users as principals with their roles and departments as metadata.</p>"},{"location":"server/pdp/#policy-enforcement-phase","title":"Policy Enforcement Phase","text":"<p>At runtime, your application enforces the configured policies by:</p> <ul> <li>Check Requests: Sending check requests to the Eunomia server</li> <li>Policy Evaluation: The server retrieves the metadata for entities given and evaluates it against the defined policies.</li> <li>Authorization Decision: The server returns a boolean result indicating whether the action should be allowed or denied.</li> </ul>"},{"location":"server/pdp/#eunomia-components","title":"Eunomia components","text":"<p>Eunomia enables developers to create Policies that determine whether Principals can perform an action on specific Resources based on their Attributes. These four core concepts \u2014 Policies, Principals, Resources, and Attributes \u2014 form the foundation of Eunomia's authorization model. Principals and Resources are both categorized as Entities.</p> <p>Let\u2019s analyze each one individually.</p>"},{"location":"server/pdp/#policies","title":"Policies","text":"<p>Policies, which are the rules that determine whether Principals can perform an action on specific Resources. The policies are stored and accessed whenever necessary. By default, we deny actions, so any allowed behavior must be explicitly defined in the policy.</p>"},{"location":"server/pdp/#principals","title":"Principals","text":"<p>Principals encompass humans, AI agents, or a combination thereof. The term is consistently plural to represent the chain of actors involved in a given action. This could range from a simple human database query to a complex interaction where a human engages with an agent that consults another, which then queries a database. The potential complexity of such chains is evident.</p> <p>Enforcing restrictions across the entire Principal chain is crucial, even when the final Principal executes the action. Access privileges are inherently intertwined within these chains.</p>"},{"location":"server/pdp/#resources","title":"Resources","text":"<p>Resources, akin to Principals, are Entities. They can be Data, Tools, or AI agents, representing what a specific list of Principals seeks to perform an action on. When AI agent access requires regulation, they function as Resources, enabling control by humans or other AI agents.</p> <p>The Resource concept is particularly crucial as, unlike legacy authorization tools focused on static resources, it extends to Tools and AI agents, providing the opportunity for a fundamentally new approach to what Principals can perform an action on.</p>"},{"location":"server/pdp/#attributes","title":"Attributes","text":"<p>Attributes are metadata associated with Entities, forming the basis for Policy creation by determining Principal actions on specific Resources.</p> <p>Attributes can be registered at configuration time or shared at runtime. Attributes encompass a broad range of elements. These may include human Principal roles, AI agent metadata, agent output shared at runtime or even inputs from external tools.</p>"},{"location":"server/pdp/#user-guides","title":"User Guides","text":"Guide Description Jump to Run the Eunomia Server Learn how to configure and run the Eunomia server  Page Create a Policy Learn how to create policies  Page Check Permissions at Runtime Learn how to check permissions at runtime  Page"},{"location":"server/pdp/check_permissions/","title":"Check Permissions at Runtime","text":"<p>The <code>POST /check</code> endpoint verifies whether a principal is allowed to perform an action on a resource based on their attributes. The API evaluates the authorization policies using a combination of fetched entity attributes and/or attributes provided at runtime. The endpoint returns a response object with a boolean value (<code>true</code> for allowed action, <code>false</code> for denied action).</p> <p>You have three options when calling this API:</p> <ol> <li> <p>Using Identifiers Only:    Supply the registered identifiers of the principal and resource. The server will fetch their attributes from the database.</p> </li> <li> <p>Using New Entities (Attributes Only):    Do not provide registered identifiers. Instead, supply the attributes directly in the request. In this case, no fetching is performed; only the runtime attributes are used.</p> </li> <li> <p>Using Identifiers and Attributes:    Provide both the registered identifiers and additional attributes. The server will merge the fetched attributes with those given at runtime before performing the authorization check.</p> </li> </ol>"},{"location":"server/pdp/check_permissions/#option-1-using-identifiers-only","title":"Option 1: Using Identifiers Only","text":"<p>In this option, you provide only the <code>uri</code> for both the principal and resource. The server will fetch the corresponding attributes from the database.</p> PythoncURLOutput <pre><code>from eunomia_sdk import EunomiaClient\n\neunomia = EunomiaClient()\n\n# Option 1: Using identifiers only.\n# Assume that the entities are already registered in the system.\n# Allowed action (the registered principal's attributes satisfy the policy)\nresult1 = eunomia.check(\n    principal_uri=\"registered-principal-001\",\n    resource_uri=\"it-desk-agent\"\n)\nprint(\"Allowed:\", result1.allowed)  # Expected output: True\n\n# Denied action (the registered principal's attributes do not meet the policy)\nresult2 = eunomia.check(\n    principal_uri=\"registered-principal-003\",\n    resource_uri=\"hr-agent\"\n)\nprint(\"Allowed:\", result2.allowed)  # Expected output: False\n</code></pre> <pre><code># Option 1: Using identifiers only.\n# Allowed action\ncurl -X POST 'http://localhost:8421/check' \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"principal_uri\": \"registered-principal-001\", \"resource_uri\": \"it-desk-agent\"}'\n\n# Denied action\ncurl -X POST 'http://localhost:8421/check' \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"principal_uri\": \"registered-principal-003\", \"resource_uri\": \"hr-agent\"}'\n</code></pre> <pre><code>{\"allowed\": true, \"reason\": \"...\"}\n{\"allowed\": false, \"reason\": \"...\"}\n</code></pre>"},{"location":"server/pdp/check_permissions/#option-2-using-new-entities-attributes-only","title":"Option 2: Using New Entities (Attributes Only)","text":"<p>In this option, you do not provide registered identifiers for the entities. Instead, you supply the attributes directly in the request. The server uses these runtime attributes exclusively for the authorization check.</p> PythoncURLOutput <pre><code># Option 2: Using new entities (attributes provided at runtime).\n# Allowed action\nresult1 = eunomia.check(\n    resource_uri=\"it-desk-agent\",\n    principal_attributes={\"department\": \"it\"}\n)\nprint(\"Allowed:\", result1.allowed)  # Expected output: True\n\nresult2 = eunomia.check(\n    resource_uri=\"hr-agent\",\n    principal_attributes={\"department\": \"hr\", \"role\": \"manager\"}\n)\nprint(\"Allowed:\", result2.allowed)  # Expected output: True\n\n# Denied action\nresult3 = eunomia.check(\n    resource_uri=\"it-desk-agent\",\n    principal_attributes={\"department\": \"sales\"}\n)\nprint(\"Allowed:\", result3.allowed)  # Expected output: False\n\nresult4 = eunomia.check(\n    resource_uri=\"hr-agent\",\n    principal_attributes={\"department\": \"hr\", \"role\": \"analyst\"}\n)\nprint(\"Allowed:\", result4.allowed)  # Expected output: False\n</code></pre> <pre><code># Option 2: Using new entities (attributes provided at runtime).\n# Allowed action\ncurl -X POST 'http://localhost:8421/check' \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"resource_uri\": \"it-desk-agent\", \"principal_attributes\": {\"department\": \"it\"}}'\n\ncurl -X POST 'http://localhost:8421/check' \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"resource_uri\": \"hr-agent\", \"principal_attributes\": {\"department\": \"hr\", \"role\": \"manager\"}}'\n\n# Denied action\ncurl -X POST 'http://localhost:8421/check' \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"resource_uri\": \"it-desk-agent\", \"principal_attributes\": {\"department\": \"sales\"}}'\n\ncurl -X POST 'http://localhost:8421/check' \\\n     -H \"Content-Type: application/json\" \\\n     -d '{\"resource_uri\": \"hr-agent\", \"principal_attributes\": {\"department\": \"hr\", \"role\": \"analyst\"}}'\n</code></pre> <pre><code>{\"allowed\": true, \"reason\": \"...\"}\n{\"allowed\": true, \"reason\": \"...\"}\n{\"allowed\": false, \"reason\": \"...\"}\n{\"allowed\": false, \"reason\": \"...\"}\n</code></pre>"},{"location":"server/pdp/check_permissions/#option-3-using-identifiers-and-attributes","title":"Option 3: Using Identifiers and Attributes","text":"<p>In this option, you provide both the registered <code>uri</code> and additional attributes in the request. The server merges the registered attributes with the runtime attributes, and the resulting set is used for the authorization check.</p> PythoncURLOutput <pre><code># Option 3: Using both identifiers and additional runtime attributes.\n# Allowed action: The registered principal is enriched with runtime attributes.\nresult1 = eunomia.check(\n    principal_uri=\"registered-principal-001\",\n    principal_attributes={\"department\": \"it\"}\n    resource_uri=\"it-desk-agent\",\n    resource_attributes={\"current_location\": \"HQ\"},\n)\nprint(\"Allowed:\", result1.allowed)  # Expected output: True\n\nresult2 = eunomia.check(\n    principal_uri=\"registered-principal-002\",\n    principal_attributes={\"department\": \"hr\", \"role\": \"manager\"}\n    resource_uri=\"hr-agent\",\n    resource_attributes={\"during_working_hours\": \"yes\"},\n)\nprint(\"Allowed:\", result2.allowed)  # Expected output: True\n\n# Denied action: Additional runtime attributes do not override the insufficient registered attributes.\nresult3 = eunomia.check(\n    resource_uri=\"it-desk-agent\",\n    resource_attributes={\"current_location\": \"Remote\"},\n    principal_uri=\"registered-principal-003\",\n    principal_attributes={\"department\": \"sales\"}\n)\nprint(\"Allowed:\", result3.allowed)  # Expected output: False\n</code></pre> <pre><code># Option 3: Using identifiers and additional runtime attributes.\n# Allowed action\ncurl -X POST 'http://localhost:8421/check' \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\"principal_uri\": \"registered-principal-001\", \"principal_attributes\": {\"department\": \"it\"}, \"resource_uri\": \"it-desk-agent\", \"resource_attributes\": {\"current_location\": \"HQ\"}}'\n\ncurl -X POST 'http://localhost:8421/check' \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\"principal_uri\": \"registered-principal-002\", \"principal_attributes\": {\"department\": \"hr\", \"role\": \"manager\"}, \"resource_uri\": \"hr-agent\", \"resource_attributes\": {\"during_working_hours\": \"yes\"}}'\n\n# Denied action\ncurl -X POST 'http://localhost:8421/check' \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\"principal_uri\": \"registered-principal-003\", \"principal_attributes\": {\"department\": \"sales\"}, \"resource_uri\": \"it-desk-agent\", \"resource_attributes\": {\"current_location\": \"Remote\"}}'\n</code></pre> <pre><code>{\"allowed\": true, \"reason\": \"...\"}\n{\"allowed\": true, \"reason\": \"...\"}\n{\"allowed\": false, \"reason\": \"...\"}\n</code></pre>"},{"location":"server/pdp/create_policies/","title":"Create a Policy","text":"<p>To enforce access control, you need to create policies that specify the rules for granting or denying actions. In general, a policy is a collection of rules that define under which conditions a principal is allowed to perform an action on a resource based on their attributes.</p>"},{"location":"server/pdp/create_policies/#create-a-policy","title":"Create a Policy","text":"<p>You can create policies using the <code>POST /admin/policies/simple</code> endpoint. The policy will be stored in the database specified in the <code>ENGINE_SQL_DATABASE_URL</code> environment variable.</p> <p>Your request JSON payload should include a rule defined by the <code>CheckRequest</code> schema, which includes:</p> <ul> <li><code>principal</code>: The conditions (attributes) that the principal performing the action must meet.</li> <li><code>resource</code>: The conditions (attributes) that the resource being acted on must meet.</li> <li><code>action</code>: (Optional) The action that the principal is trying to perform on the resource.</li> </ul> PythoncURLOutput <pre><code>from eunomia_core.schemas import CheckRequest, PrincipalCheck, ResourceCheck\nfrom eunomia_sdk import EunomiaClient\n\neunomia = EunomiaClient()\n\npolicy = eunomia.create_simple_policy(\n    CheckRequest(\n        principal=PrincipalCheck(attributes={\"department\": \"it\"}),\n        resource=ResourceCheck(attributes={\"agent-id\": \"it-desk-agent\"}),\n        action=\"access\",\n    ),\n    name=\"it-desk-policy\",\n)\n</code></pre> <p>Info</p> <p>To use the Python SDK, check out its documentation for installation instructions.</p> <pre><code>curl -X POST 'http://localhost:8421/admin/policies/simple?name=it-desk-policy' \\\n    -H \"Content-Type: application/json\" \\\n    -d '{\"principal\": {\"attributes\": {\"department\": \"it\"}}, \"resource\": {\"attributes\": {\"agent-id\": \"it-desk-agent\"}}, \"action\": \"access\"}'\n</code></pre> <pre><code>{\n    \"name\":\"it-desk-policy\",\n    \"rules\":[\n        {\n            \"effect\": \"allow\",\n            \"principal_conditions\": [{\"path\": \"attributes.department\", \"operator\": \"==\", \"value\": \"it\"}],\n            \"resource_conditions\": [{\"path\": \"attributes.agent-id\", \"operator\": \"==\", \"value\": \"it-desk-agent\"}],\n            \"actions\": [\"access\"]\n        },\n    ],\n    \"default_effect\": \"deny\"\n}\n</code></pre>"},{"location":"server/pdp/run_server/","title":"Run the Eunomia Server","text":"<p>The Eunomia server is a standalone service that manages the authorization logic for your AI Agent. It is self-hosted and provides a REST API for your application.</p> <p>In this guide, you'll learn how to configure and run the Eunomia server.</p>"},{"location":"server/pdp/run_server/#server-configuration","title":"Server Configuration","text":"<p>To run the Eunomia server, you must configure the following parameters:</p> Parameter Description Default Value <code>PROJECT_NAME</code> Name of the project <code>Eunomia Server</code> <code>DEBUG</code> Flag to enable debug mode <code>False</code> <code>ENGINE_SQL_DATABASE</code> Flag to enable persistence of policies in a database <code>True</code> <code>ENGINE_SQL_DATABASE_URL</code> Path to the policy database file <code>sqlite:///.db/eunomia_db.sqlite</code> <code>FETCHERS</code> Dictionary of fetchers to use <code>{\"registry\": {\"sql_database_url\": \"sqlite:///.db/eunomia_db.sqlite\"}}</code> <code>ADMIN_AUTHN_REQUIRED</code> Flag to enable Admin API authentication via PSK <code>False</code> <code>ADMIN_API_KEY</code> Pre-shared key for Admin API authentication <code>\"\"</code> <code>BULK_CHECK_MAX_REQUESTS</code> Maximum number of requests allowed in bulk check operations <code>100</code> <code>BULK_CHECK_BATCH_SIZE</code> Batch size for processing bulk check requests <code>10</code> <p>All parameters have default values, you can override any of them by setting environment variables, e.g., using a <code>.env</code> file.</p> <p>The <code>registry</code> fetcher is provided by default to register and fetch metadata from a database.</p>"},{"location":"server/pdp/run_server/#running-the-server","title":"Running the Server","text":""},{"location":"server/pdp/run_server/#run-locally","title":"Run Locally","text":"<p>If you have installed the <code>eunomia-ai</code> package, you can start the Eunomia server by executing the command in your terminal:</p> <pre><code>eunomia server\n</code></pre> <p>The server will start and listen for requests on address <code>127.0.0.1</code> and port <code>8421</code>. You can change the address and port by using the <code>--host</code> and <code>--port</code> flags:</p> <pre><code>eunomia server --host 0.0.0.0 --port 8080\n</code></pre> <p>You can also enable the automatic reload of the server on file changes by using the <code>--reload</code> flag:</p> <pre><code>eunomia server --reload\n</code></pre>"},{"location":"server/pdp/run_server/#run-with-docker","title":"Run with Docker","text":"<p>You can also run the Eunomia server using the Docker image:</p> <pre><code>docker run -d -p 8421:8421 --name eunomia ttommitt/eunomia-server:latest\n</code></pre> <p>Pin to a specific version if needed:</p> <pre><code>docker run -d -p 8421:8421 --name eunomia ttommitt/eunomia-server:0.3.5\n</code></pre> <p>Modify the server configuration by providing environment variables:</p> <pre><code>docker run -d -p 8421:8421 --name eunomia \\\n    -e DEBUG=True \\\n    -e ENGINE_SQL_DATABASE_URL=postgresql://user:password@host:port/database \\\n    ttommitt/eunomia-server:latest\n</code></pre> <p>Info</p> <p>The Docker image does not come with persistent storage on its own and will lose all data when the container is stopped. To persist the database, you need to mount a volume to the container or connect to an external database.</p>"}]}